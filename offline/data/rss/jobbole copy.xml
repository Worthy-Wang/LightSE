<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>文章 &#8211; 伯乐在线</title>
	<atom:link href="http://blog.jobbole.com/feed/" rel="self" type="application/rss+xml" />
	<link>http://blog.jobbole.com</link>
	<description></description>
	<lastBuildDate>Wed, 26 Oct 2016 08:06:05 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.5.4</generator>
	<item>
		<title>c 语言宏定义 #define 的理解与资料整理</title>
		<link>http://blog.jobbole.com/107047/</link>
		<comments>http://blog.jobbole.com/107047/#respond</comments>
		<pubDate>Wed, 26 Oct 2016 08:06:05 +0000</pubDate>
		<dc:creator><![CDATA[中二饼]]></dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[#define]]></category>
		<category><![CDATA[C语言]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=107047</guid>
		<description><![CDATA[<p>define 宏定义是个演技非常高超的替身演员，但也会经常耍大牌的，所以我们用它要慎之又慎。它可以出现在代码的任何地方，从本行宏定义开始，以后的代码就就都认识这个宏了；也可以把任何东西定义成宏。因为编译器会在预编译的时候用真身替换替身，而在我们的代码里面却又用常常用替身来帮忙。</p><p><a href="http://blog.jobbole.com/107047/">c 语言宏定义 #define 的理解与资料整理</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<div>
<h3>1. 利用 define 来定义 数值宏常量</h3>
</div>
<p>#define 宏定义是个演技非常高超的替身演员，但也会经常耍大牌的，所以我们用它要慎之又慎。它可以出现在代码的任何地方，从本行宏定义开始，以后的代码就就都认识这个宏了；也可以把任何东西定义成宏。因为编译器会在预编译的时候用真身替换替身，而在我们的代码里面却又用常常用替身来帮忙。</p>
<p>看例子：</p>
<div>
<pre class="crayon-plain-tag">#define PI 3.141592654</pre>
</div>
<p>在此后的代码中你尽可以使用PI 来代替3.141592654，而且你最好就这么做。不然的话，如果我要把PI 的精度再提高一些，你是否愿意一个一个的去修改这串数呢？你能保证不漏不出错？而使用PI 的话，我们却只需要修改一次（这是十分高效的）。</p>
<p>这种情况还不是最要命的，我们再看一个例子：</p>
<div>
<pre class="crayon-plain-tag">#define ERROR_POWEROFF  -1</pre>
</div>
<p>如果你在代码里不用ERROR_POWEROFF 这个宏而用-1，尤其在函数返回错误代码的时候（往往一个开发一个系统需要定义很多错误代码）。肯怕上帝都无法知道-1 表示的是什么意思吧。这个-1，我们一般称为“魔鬼数”，上帝遇到它也会发狂的。所以，我奉劝你代码里一定不要出现“魔鬼数”。(这里是从代码可读性的角度进行考虑！)</p>
<p>但是我们利用define来定义数值类型的数据，一般只是用来定义  常量 ，如果 要定义一些变量，则可以使用c语言中const这个关键字。</p>
<p>我们已经讨论了const 这个关键字，我们知道const 修饰的数据是有类型的，而define 宏定义的数据没有类型。为了安全，我建议你以后在定义一些宏常数的时候用const代替，编译器会给const 修饰的只读变量做类型校验，减少错误的可能。</p>
<p>但一定要注意const修饰的不是常量而是readonly 的变量，const 修饰的只读变量不能用来作为定义数组的维数，也不能放在case 关键字后面。</p>
<h3>2.利用 define 来定义 字符串宏常量</h3>
<p>除了定义宏常数之外，经常还用来定义字符串，尤其是<strong>路径</strong>：</p>
<div>
<pre class="crayon-plain-tag">A),#define ENG_PATH_1 E:\English\listen_to_this\listen_to_this_3
B),#define ENG_PATH_2 “E:\English\listen_to_this\listen_to_this_3”</pre>
</div>
<p>噢，到底哪一个正确呢？如果路径太长，一行写下来比较别扭怎么办？用反斜杠接续符 &#8221; 啊：</p>
<div>
<pre class="crayon-plain-tag">C), #define ENG_PATH_3 E:\English\listen_to_this\listen\_to_this_3</pre>
</div>
<p>还没发现问题？这里用了4 个反斜杠，到底哪个是接续符？回去看看接续符反斜杠。</p>
<p>反斜杠作为接续符时，在本行其后面不能再有任何字符，空格都不行。所以，只有最后一个反斜杠才是接续符。至于A)和B)，那要看你怎么用了，既然define 宏只是简单的替换，那给ENG_PATH_1 加上双引号不就成了：“ENG_PATH_1”。</p>
<p>但是请注意：有的系统里规定路径的要用双反斜杠“\”,比如（这是正确的版本）：</p>
<div>
<pre class="crayon-plain-tag">#define ENG_PATH_4 E:\\English\\listen_to_this\\listen_to_this_3</pre>
</div>
<h3>3.用 define 宏定义 注释符号</h3>
<p>上面对define 的使用都很简单，再看看下面的例子：</p>
<div>
<pre class="crayon-plain-tag">#define BSC //
#define BMC /*
#define EMC */
 
D),BSC my single-line comment
E),BMC my multi-line comment EMC</pre>
</div>
<p>D)和E)都错误，为什么呢？因为注释先于预处理指令被处理,当这两行被展开成//…或/*…*/时,注释已处理完毕,此时再出现//…或/*…*/自然错误.（这一条需要对编译预处理有所理解，才能体会。看来我还得再写一篇这方面的文章。）</p>
<p>因此,试图用宏开始或结束一段注释是不行的。</p>
<h3>4.用define 宏定义表达式</h3>
<p>这些都好理解，下面来点有“技术含量”的，定义一年有多少秒：</p>
<div>
<pre class="crayon-plain-tag">#define SEC_A_YEAR 60*60*24*365</pre>
</div>
<p>这个定义没错吧？很遗憾，很有可能错了，至少不可靠。你有没有考虑在16 位系统下把这样一个数赋给整型变量的时候可能会发生溢出？一年有多少秒也不可能是负数吧。</p>
<p>改一下：</p>
<div>
<pre class="crayon-plain-tag">#define SEC_A_YEAR （60*60*24*365）UL</pre>
</div>
<p>又出现一个问题，这里的括号到底需不需要呢？继续看一个例子，定义一个宏函数，求x 的平方：</p>
<div>
<pre class="crayon-plain-tag">#define SQR (x) x * x</pre>
</div>
<p>对不对？试试：假设x 的值为10，SQR (x)被替换后变成10*10。没有问题。</p>
<p>再试试：假设x 的值是个表达式10+1，SQR (x)被替换后变成10+1*10+1。问题来了，这并不是我想要得到的。怎么办？括号括起来不就完了？</p>
<div>
<pre class="crayon-plain-tag">#define SQR (x) （（x）*（x））</pre>
</div>
<p>最外层的括号最好也别省了，看例子，求两个数的和：</p>
<div>
<pre class="crayon-plain-tag">#define SUM (x) （x）+（x）</pre>
</div>
<p>如果x 的值是个表达式5*3,而代码又写成这样：SUM (x)* SUM (x)。替换后变成：（5*3）+（5*3）*（5*3）+（5*3）。又错了！所以最外层的括号最好也别省了。我说过define 是个演技高超的替身演员，但也经常耍大牌。要搞定它其实很简单，别吝啬括号就行了。</p>
<p>注意这一点：宏函数被调用时是以实参代换形参。而不是“值传送”。</p>
<h3>5.宏定义中的空格</h3>
<p>另外还有一个问题需要引起注意，看下面例子：</p>
<div>
<pre class="crayon-plain-tag">#define SUM （x） （x）+（x）</pre>
</div>
<p>这还是定义的宏函数SUM（x）吗？显然不是。编译器认为这是定义了一个宏：SUM，其代表的是（x） （x）+（x）。</p>
<p>为什么会这样呢？其关键问题还是在于SUM 后面的这个空格。所以在定义宏的时候一定要注意什么时候该用空格，什么时候不该用空格。这个空格仅仅在定义的时候有效，在使用这个宏函数的时候，空格会被编译器忽略掉。也就是说，上一节定义好的宏函数SUM（x）在使用的时候在SUM 和（x）之间留有空格是没问题的。比如：SUM（3）和SUM （3）的意思是一样的。</p>
<h3>6.#undef</h3>
<p>#undef 是用来撤销宏定义的，用法如下：</p>
<div>
<pre class="crayon-plain-tag">#define PI 3.141592654

…

// code

#undef PI</pre>
</div>
<p>//下面的代码就不能用PI 了，它已经被撤销了宏定义。</p>
<p>写好C语言，漂亮的宏定义很重要，使用宏定义可以防止出错，提高可移植性，可读性，方便性 等等。下面列举一些成熟软件中常用得宏定义：</p>
<p>1，防止一个头文件被重复包含</p>
<div>
<pre class="crayon-plain-tag">#ifndef COMDEF_H

#define COMDEF_H

//头文件内容

#endif</pre>
</div>
<p>2，重新定义一些类型，防止由于各种平台和编译器的不同，而产生的类型字节数差异，方便移植。这里已经不是#define的范畴了。</p>
<div>
<pre class="crayon-plain-tag">typedef unsigned char boolean; /* Boolean value type. */
typedef unsigned long int uint32; /* Unsigned 32 bit value */
typedef unsigned short uint16; /* Unsigned 16 bit value */
typedef unsigned char uint8; /* Unsigned 8 bit value */
typedef signed long int int32; /* Signed 32 bit value */
typedef signed short int16; /* Signed 16 bit value */
typedef signed char int8; /* Signed 8 bit value */
//下面的不建议使用
typedef unsigned char byte; /* Unsigned 8 bit value type. */
typedef unsigned short word; /* Unsinged 16 bit value type. */
typedef unsigned long dword; /* Unsigned 32 bit value type. */
typedef unsigned char uint1; /* Unsigned 8 bit value type. */
typedef unsigned short uint2; /* Unsigned 16 bit value type. */
typedef unsigned long uint4; /* Unsigned 32 bit value type. */
typedef signed char int1; /* Signed 8 bit value type. */
typedef signed short int2; /* Signed 16 bit value type. */
typedef long int int4; /* Signed 32 bit value type. */
typedef signed long sint31; /* Signed 32 bit value */
typedef signed short sint15; /* Signed 16 bit value */
typedef signed char sint7; /* Signed 8 bit value */</pre>
</div>
<p>3，得到指定地址上的一个字节或字</p>
<div>
<pre class="crayon-plain-tag">#define MEM_B( x ) ( *( (byte *) (x) ) )
#define MEM_W( x ) ( *( (word *) (x) ) )</pre>
</div>
<p>4，求最大值和最小值</p>
<div>
<pre class="crayon-plain-tag">#define MAX( x, y ) ( ((x) &gt; (y)) ? (x) : (y) )
#define MIN( x, y ) ( ((x) &lt; (y)) ? (x) : (y) )</pre>
</div>
<p>5，得到一个field在结构体(struct)中的偏移量</p>
<div>
<pre class="crayon-plain-tag">#define FPOS( type, field ) \
/*lint -e545 */ ( (dword) &amp;(( type *) 0)-&gt; field ) /*lint +e545 */</pre>
</div>
<p>6,得到一个结构体中field所占用的字节数</p>
<div>
<pre class="crayon-plain-tag">#define FSIZ( type, field ) sizeof( ((type *) 0)-&gt;field )</pre>
</div>
<p>7，按照LSB格式把两个字节转化为一个Word</p>
<div>
<pre class="crayon-plain-tag">#define FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )</pre>
</div>
<p>8，按照LSB格式把一个Word转化为两个字节</p>
<div>
<pre class="crayon-plain-tag">#define FLOPW( ray, val ) \
 
(ray)[0] = ((val) / 256); \
 
(ray)[1] = ((val) &amp; 0xFF)</pre>
</div>
<p>9，得到一个变量的地址（word宽度）</p>
<div>
<pre class="crayon-plain-tag">#define B_PTR( var ) ( (byte *) (void *) &amp;(var) )
 
#define W_PTR( var ) ( (word *) (void *) &amp;(var) )</pre>
</div>
<p>10，得到一个字的高位和低位字节</p>
<div>
<pre class="crayon-plain-tag">#define WORD_LO(xxx) ((byte) ((word)(xxx) &amp; 255))
 
#define WORD_HI(xxx) ((byte) ((word)(xxx) &gt;&gt; 8))</pre>
</div>
<p>11，返回一个比X大的最接近的8的倍数</p>
<div>
<pre class="crayon-plain-tag">#define RND8( x ) ((((x) + 7) / 8 ) * 8 )</pre>
</div>
<p>12，将一个字母转换为大写</p>
<div>
<pre class="crayon-plain-tag">#define UPCASE( c ) ( ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') ? ((c) - 0x20) : (c) )</pre>
</div>
<p>13，判断字符是不是10进值的数字</p>
<div>
<pre class="crayon-plain-tag">#define DECCHK( c ) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')</pre>
</div>
<p>14，判断字符是不是16进值的数字</p>
<div>
<pre class="crayon-plain-tag">#define HEXCHK( c ) ( ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9') ||\
 
((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'F') ||\
 
((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'f') )</pre>
</div>
<p>15，防止溢出的一个方法</p>
<div>
<pre class="crayon-plain-tag">#define INC_SAT( val ) (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))</pre>
</div>
<p>16，返回数组元素的个数</p>
<div>
<pre class="crayon-plain-tag">#define ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )</pre>
</div>
<p>17，返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2^n)</p>
<div>
<pre class="crayon-plain-tag">#define MOD_BY_POWER_OF_TWO( val, mod_by ) \
( (dword)(val) &amp; (dword)((mod_by)-1) )</pre>
</div>
<p>18，对于IO空间映射在存储空间的结构，输入输出处理</p>
<div>
<pre class="crayon-plain-tag">#define inp(port) (*((volatile byte *) (port)))
 
#define inpw(port) (*((volatile word *) (port)))
 
#define inpdw(port) (*((volatile dword *)(port)))
 
#define outp(port, val) (*((volatile byte *) (port)) = ((byte) (val)))
 
#define outpw(port, val) (*((volatile word *) (port)) = ((word) (val)))
 
#define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))</pre>
</div>
<p>19,使用一些宏跟踪调试</p>
<p>A N S I标准说明了五个预定义的宏名。它们是：</p>
<div>
<pre class="crayon-plain-tag">_ LINE _
_ FILE _
_ DATE _
_ TIME _
_ STDC _</pre>
</div>
<p>可以定义宏，例如:</p>
<p>当定义了_DEBUG，输出数据信息和所在文件所在行</p>
<div>
<pre class="crayon-plain-tag">#ifdef _DEBUG
 
#define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
 
#else
 
#define DEBUGMSG(msg,date)
 
#endif</pre>
</div>
<p>20，宏定义防止使用是错误</p>
<p><strong>用小括号包含。 </strong></p>
<p>例如：</p>
<div>
<pre class="crayon-plain-tag">#define ADD(a,b) （a+b）</pre>
</div>
<p>用<strong>do{}while(0)</strong>语句包含多语句防止错误</p>
<p>例如：</p>
<div>
<pre class="crayon-plain-tag">#define DO(a,b) a+b;\
 
a++;</pre>
</div>
<p>应用时：</p>
<div>
<pre class="crayon-plain-tag">if(….)
 
DO(a,b); //产生错误
 
else</pre>
</div>
<p>解决方法: 代码就只会执行一次。和直接加花括号有什么区别呢。哦对，不能随便在程序中，任意加｛｝，组成代码块的。</p>
<div>
<pre class="crayon-plain-tag">#define DO(a,b) do{a+b;\
 
a++;}while(0)</pre>
</div>
<p><a href="http://blog.jobbole.com/107047/">c 语言宏定义 #define 的理解与资料整理</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/107047/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>程序员如何保持身体健康？</title>
		<link>http://blog.jobbole.com/107038/</link>
		<comments>http://blog.jobbole.com/107038/#comments</comments>
		<pubDate>Wed, 26 Oct 2016 02:31:22 +0000</pubDate>
		<dc:creator><![CDATA[Sam哥哥技术博客]]></dc:creator>
				<category><![CDATA[职场]]></category>
		<category><![CDATA[健康]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=107038</guid>
		<description><![CDATA[<p>最近听说公司的几个同事都大病了一场，有的还进行了大的手术，差点跟阎王爷报道了。努力工作固然重要，但是一定注意身体，身体不好了，随着来的就是，工作和生活双失。我根据自己的实践，列举了几个建议。</p><p><a href="http://blog.jobbole.com/107038/">程序员如何保持身体健康？</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p>最近听说公司的几个同事都大病了一场，有的还进行了大的手术，差点跟阎王爷报道了。努力工作固然重要，但是一定注意身体，身体不好了，随着来的就是，工作和生活<strong>双失</strong>。</p>
<p>我根据自己的实践，列举了几点习惯，可能可以帮助程序员调整一下工作和生活的节奏，从而达到生活和工作平衡，进而改进身体体质和健康。</p>
<h3>1、请早睡</h3>
<p>早睡都做不到的话，其他就都别谈了。像要跑步，要健身，要努力工作，如果没有早睡作为前提，通通没用的。只有早睡，白天<strong>精神气才有可能足，精神气足了，干事情才有劲</strong>。熬夜的话，现在80后程序员真心是熬不起了，你可能经常有这样的感慨：怎么现在敖几次夜后，就浑身不爽呢？。</p>
<p><img class="alignnone" src="http://ww3.sinaimg.cn/mw690/63918611gw1f95gpjcqqtj21ao0zhduf.jpg" width="690" height="524" /></p>
<h3>2、请吃好</h3>
<p>像街边摊，大排档，这些地方就别去了，他们用的<strong>油不好，食材也不好</strong>，你把这些不健康的东西吃进肚子里，真心会把身体搞坏。如果公司有食堂了，就去食堂吃，如果没有食堂的话，就自己做饭，然后带饭到公司。你自己可以仔细对比观察周围的人，吃的健康的人的起色和精神气通常都非常好。</p>
<h3>3、请有规律的准时吃饭</h3>
<p>比如吃中午饭，你第一天11点吃，第二天12点半吃，第三天一点半吃，这种情况，你的胃是吃不消的。得有规律的吃。最好能跟同事一起吃，这样比较准时，同时，跟大家一起吃，你也自然会吃的比较慢。吃的慢是护胃的一种非常好的方式。</p>
<p>千万不好因为工作忙，就不按时准时的吃饭。这种不准时吃饭，吃饭快的，可能会导致胃癌。</p>
<h3>4、请健身</h3>
<p>有了前面3点之后，你才来考虑健身的问题。健身除了塑形之外呢，还可以<strong>增强体质</strong>。健身不一定要去健身房的，在家里就可以了。你只要买了哑铃和杠铃，大部分健身动作就都可以完成了。不过健身一定要注意<strong>动作的正确性</strong>,这个是极其关键的，动作不对，除了健身效果不明显之外，还会伤到肌肉和骨头。</p>
<p>如果周围没有熟悉健身的朋友，可以看一些健身视频，慢慢揣摩动作。</p>
<p>本人就是个健身爱好者，每天都健身，不健身就浑身不爽。二话不说，附上本人的健身后效果图。(<em>^__^</em>) 嘻嘻……</p>
<p><img title="" src="http://img.blog.csdn.net/20161026083733216" alt="这里写图片描述" /></p>
<p><img title="" src="http://img.blog.csdn.net/20161026083748399" alt="这里写图片描述" /></p>
<h3>5、请跑步或者游泳</h3>
<p>游泳的效果是跑步的三倍，只是我自己的实践经验。当然女生的话，由于头发问题，游泳不能经常做，但是跑步则可以。游泳和跑步这些有氧运动，可以改进心肺机能。</p>
<p><img class="alignnone" src="http://ww1.sinaimg.cn/mw690/63918611gw1f95glthz6ij20rs0k4aby.jpg" width="690" height="500" /></p>
<h3>6、加班不要太严重了</h3>
<p>这个才是最关键的，经常性的频繁的加班，必定打乱你所有的生活节奏，节奏不对，身体就很快吃不消，各种健康问题也都随之而来。</p>
<h3>7、多掌握一些编程以外的技能</h3>
<p>程序员不能简单的做码农，日子也要过的精彩。平时可以多学习一些技能，像健身、乒乓球、羽毛球、溜冰、唱歌、保龄球、钢琴、吉他、做家常菜等等。可以帮助你把日子过的精彩些，要往自己身上多投资。</p>
<p><a href="http://blog.jobbole.com/107038/">程序员如何保持身体健康？</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/107038/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>全栈必备：DevOps</title>
		<link>http://blog.jobbole.com/107021/</link>
		<comments>http://blog.jobbole.com/107021/#respond</comments>
		<pubDate>Wed, 26 Oct 2016 01:49:30 +0000</pubDate>
		<dc:creator><![CDATA[abel_cao]]></dc:creator>
				<category><![CDATA[IT技术]]></category>
		<category><![CDATA[DevOps]]></category>
		<category><![CDATA[全栈]]></category>
		<category><![CDATA[运维]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=107021</guid>
		<description><![CDATA[<p>全栈不仅是一个研发多面手，而且必须要关注产品的最终交付，以及线上服务的稳定运行。工具化使开发、交付、运维紧密地联系在一起，于是DevOps 逐渐成为了全栈们手中的利器，但由于DevOps的复杂性，如果没有科学的人员、流程与工具相配合，DevOps根本无从谈起，因此，DevOps 更是一柄双刃剑。</p><p><a href="http://blog.jobbole.com/107021/">全栈必备：DevOps</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<div class="meta-top">全栈不仅是一个研发多面手，而且必须要关注产品的最终交付，以及线上服务的稳定运行。工具化使开发、交付、运维紧密地联系在一起，于是DevOps 逐渐成为了全栈们手中的利器，但由于DevOps的复杂性，如果没有科学的人员、流程与工具相配合，DevOps根本无从谈起，因此，DevOps 更是一柄双刃剑。</div>
<div class="show-content">
<h1><a name="t1"></a>什么是DevOps呢？</h1>
<p>先看一下wiki百科给出的定义：</p>
<blockquote><p>DevOps (a clipped compound of development and operations) is a culture, movement or practice that emphasizes the collaboration and communication of both software developers and other information-technology (IT) professionals while automating the process of software delivery and infrastructure changes. It aims at establishing a culture and environment where building, testing, and releasing software can happen rapidly, frequently, and more reliably.</p></blockquote>
<p>简单地说，DevOps是一种开发、测试、运营、维护部门之间沟通、协作与整合的软件过程、方法与系统。</p>
<p>DevOps是一种高度强调人与人间互动的工作方式，不能先入为主地认为参与者了解某方面技能，在完成高频率部署的同时，提高生产环境的可靠稳定和安全行。</p>
<p>DevOps能够为团队提供一种极具凝聚力的文化氛围，DevOps不光是一个方法理念，而且是一个有力的技术手段，人员、文化、流程与工具这几大要素在DevOps中同样重要。</p>
<h1><a name="t2"></a>为什么DevOps姗姗来迟</h1>
<p>DevOps 的概念在2009年就诞生了，但没有相关的技术支持，只是出现在教科书和论文里。然而，近年来所谓DevOps的最佳实践逐渐越来越多，原因何在？</p>
<ol>
<li>云服务的普遍使用，各种云服务成为IT基础设施中不可分隔的一部分。运维有一个很重要的概念就是Infrastructure as code。</li>
<li>容器技术开始成熟，特别是Docker技术的大行其道。容器 Container是用来存储和组织其他对象的对象。Docker是一个开源的应用容器引擎。</li>
<li>微服务架构技术的广泛使用。<br />
微服务 MicroService是指一个单纯的小型有意义的功能。<br />
微服务，是支撑DevOps方法的手段，传统开发是在一个服务器里面，把各种元素装在一起组合成一个程序，但微服务是每一个服务是一个单独的单元，可以部署在不同的服务器上，通过SOA的方法，把它连接起来，再提供整个功能。<br />
微服务是由一个个团队组成，每团队有自己的服务，做好后，可以独立的进行测试、开发、部署，然后整个应用组合到一起。张侠表示，开发运维一体化、微服务和Container是同等的，把它们组合起来，加上云的手段才成为可能。</li>
</ol>
<p>4.敏捷开发流程的深入人心。</p>
<p>诸如Scrum, Agile, Kanban等敏捷方式被团队广泛使用，TDD、BDD、DDD这些测试驱动设计、行为驱动设计、域驱动设计等设计方式的采纳，CI和CD这些持续集成和持续部署等方式的实施，这些都是对DevOps的强烈需求。</p>
<h1><a name="t3"></a>DevOps中的技术栈与工具链</h1>
<p>在全栈眼中，Everything is Code，所以DevOps 是通过技术工具链完成持续集成、持续交付、用户反馈和系统优化的整合，实现跨团队的无缝协作。</p>
<p>DevOps 中涉及的技术栈与工具链如下：</p>
<ul>
<li>DevOps 流程门户： 这是统一操作的web网站，主要是进度看板，Sprint周期等。本着拿来主义，在一定条件下，可以采用类似Trello，worktile等工具代替。</li>
<li>身份及访问管理： 用户权限管理的重要组成，可以采用RABC的方式实现，也可以与LDAP服务对接</li>
<li>产品管理： 产品的需求，定义，依赖，推广等产品线的全面管理，confluence 可能是个不错的选择，禅道也可以满足一部分的功能</li>
<li>配置管理： 提高产品的配置维护能力，zookeeper 大概是不二之选。</li>
<li>持续集成： 提供持续集成任务调度和执行的能力，Jenkins的用武之地，提供产品和组件自动编译、打包和部署的能力，支持编译和部署的流程编制，进度跟踪和日志查看</li>
<li>环境管理： 提供资源配给和负载均衡的能力，需要配合云服务的资源管理能力。初级的负载均衡可以选择nginx或者Haproxy，生产环境的入口最好采用云服务的SLB负载均衡，以便简单地解决HA的问题。资源的调度采用云的弹性能力，辅助脚本实现。同时，微服务的容器化（docker）管理需要特别关注。</li>
<li>质量反馈： 提供产品的质量管理和监控能力，包括测试用例，缺陷跟踪和质量监控。Jira 是个不错的选择，其他的开源工具例如禅道，bugzila，mantis等等，因团队而异。</li>
<li>版本控制： 代码库的创建和维护，分支管理等。Git 几乎是行业的标准，可以自建Git仓库的服务器，也可以使用github 或者bitbucket这样的第三方服务。</li>
<li>自动化测试： 包括客户端与服务器端的自动化测试框架，例如Appium，Selenium 以及各种Mock技术和xUnit</li>
<li>文档管理：各种开发、运维、部署文档的统一管理，同样最好放到git上，同时指出文档的自动化生成</li>
<li>运营管理：这就是传说中的OAM 中心，这是广义的运营，其中还包括运维的部分。OAM 不但提供了业务系统的运营操作，还提供了面向运维的统一Monitor，alarm，fault handling等能力，以及产品的资源使用和运行状况等，涉及的技术很多，尽量采用云监控＋脚本的方式，规模较小时可以尝zZabbix 实现部分功能。</li>
<li>沟通管理： 敏捷的一个原则就是沟通优于文档，IM是团队必备，微信和QQ可以满足大部分的需求，但是Slack 因为其强大的web hook 功能显得更加出色。</li>
</ul>
<h1><a name="t4"></a>DevOps 的双刃剑</h1>
<p>DevOps 的成功与技术、流程和组织的全面支撑是密不可分的。技术栈和工具链只是DevOps的一个前提和基础，技术方面的实践相对容易，流程较难，组织变革最为艰难。DevOps还是以工程实践为主，管理实践这块，像Scrum成体系的还比较少。DevOps玩得好，可以提高团队的生产力。若是玩不好，可能还不如传统的生产模式有效率。</p>
<p>狭义上看，DevOps主要困难点在于开发和运维是两种完全不同性质的技术工作。很多开发的同事，看着运维人员整天就是玩几个工具，写几个脚本，觉得蛮简单，实际上，很多东西要在生产环境下快速稳定应用，并没有看上去那么容易。生产系统少出问题（软件本身bug除外）是运维的绩效，多实现业务需求是开发的绩效，这一少一多，体现了两种技术角色的根本性区别。</p>
<p>业务部门压力往往导致技术部门的任务主要是求“快”，在这种情况下，DevOps必然失衡，因为只追求快，就不需要ops了，只需要dev加班加点即可，不重视ops，结果必然是可悲的，往往业务上线后鸡飞狗跳，各种问题不断。在激烈竞争环境中，出几次事故就可能对产品形象的伤害很大。</p>
<p>对全栈来说，业务初期到底要不要考虑高可用？从Dev角度看，简洁明快的实现就行了，从Ops的角度看，高可用、监控、报表这些东西在业务正式上线前就是必须要考虑的。</p>
<p>因此，DevOps实施成功的关键，涉及到团队管理，项目管理，技术管理等诸多方面。DevOps并非治病良药，如果团队正能量大，实施起来就相对容易，否则引入DevOps可能也无法改变什么。对于一个全栈而言，DevOps是一柄必备的双刃剑。</p>
</div>
<p><a href="http://blog.jobbole.com/107021/">全栈必备：DevOps</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/107021/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>C++ 的强制类型转换</title>
		<link>http://blog.jobbole.com/107033/</link>
		<comments>http://blog.jobbole.com/107033/#respond</comments>
		<pubDate>Tue, 25 Oct 2016 06:54:38 +0000</pubDate>
		<dc:creator><![CDATA[中二饼]]></dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[类型转换]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=107033</guid>
		<description><![CDATA[<p>Q:什么是C风格转换？什么是static_cast, dynamic_cast 以及 reinterpret_cast？区别是什么？为什么要注意？
A:转换的含义是通过改变一个变量的类型为别的类型从而改变该变量的表示方式。为了类型转换一个简单对象为另一个对象你会使用传统的类型转换操作符。</p><p><a href="http://blog.jobbole.com/107033/">C++ 的强制类型转换</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p>Q:什么是C风格转换？什么是static_cast, dynamic_cast 以及 reinterpret_cast？区别是什么？为什么要注意？</p>
<p>A:转换的含义是通过改变一个变量的类型为别的类型从而改变该变量的表示方式。为了类型转换一个简单对象为另一个对象你会使用传统的类型转换操作符。</p>
<p>比如，为了转换一个类型为doubole的浮点数的指针到整型：<br />
代码</p><pre class="crayon-plain-tag">int i;
double d;
i = (int) d;</pre><p>或者：</p><pre class="crayon-plain-tag">i = int (d);</pre><p>对于具有标准定义转换的简单类型而言工作的很好。然而，这样的转换符也能不分皂白的应用于类（class）和类的指针。ANSI-C++标准定义了四个新的转换符：&#8217;reinterpret_cast&#8217;, &#8216;static_cast&#8217;, &#8216;dynamic_cast&#8217; 和 &#8216;const_cast&#8217;，目的在于控制类(class)之间的类型转换。</p>
<p>代码:</p><pre class="crayon-plain-tag">reinterpret_cast&lt;new_type&gt;(expression)
dynamic_cast&lt;new_type&gt;(expression)
static_cast&lt;new_type&gt;(expression)
const_cast&lt;new_type&gt;(expression)</pre><p></p>
<h3>1 reinterpret_cast</h3>
<p>reinterpret_cast 转换一个指针为其它类型的指针。它也允许从一个指针转换为整数类型。反之亦然。（译注：是指针具体的地址值作为整数值？）</p>
<p>这个操作符能够在非相关的类型之间转换。操作结果只是简单的从一个指针到别的指针的值的二进制拷贝。在类型之间指向的内容不做任何类型的检查和转换。如果情况是从一个指针到整型的拷贝，内容的解释是系统相关的，所以任何的实现都不是方便的。一个转换到足够大的整型能够包含它的指针是能够转换回有效的指针的。</p>
<p>代码:</p><pre class="crayon-plain-tag">class A {};
class B {};
A * a = new A;
B * b = reinterpret_cast&lt;B *&gt;(a);</pre><p>reinterpret_cast 就像传统的类型转换一样对待所有指针的类型转换。</p>
<h3>2 static_cast</h3>
<p>static_cast 允许执行任意的隐式转换和相反转换动作。（即使它是不允许隐式的）</p>
<p>意思是说它允许子类类型的指针转换为父类类型的指针（这是一个有效的隐式转换），同时，也能够执行相反动作：转换父类为它的子类。在这最后例子里，被转换的父类没有被检查是否与目的类型相一致。</p>
<p>代码：</p><pre class="crayon-plain-tag">class Base {};
class Derived : public Base {};

Base *a = new Base;
Derived *b = static_cast&lt;Derived *&gt;(a);</pre><p>static_cast 除了操作类型指针，也能用于执行类型定义的显式的转换，以及基础类型之间的标准转换:</p>
<p>代码:</p><pre class="crayon-plain-tag">double d = 3.14159265;
int i = static_cast&lt;int&gt;(d);</pre><p></p>
<h3>3 dynamic_cast</h3>
<p>dynamic_cast只用于对象的指针和引用。当用于多态类型时，它允许任意的隐式类型转换以及相反过程。不过，与static_cast不同，在后一种情况里（注：即隐式转换的相反过程），dynamic_cast会检查操作是否有效。也就是说，它会检查转换是否会返回一个被请求的有效的完整对象。</p>
<p>检测在运行时进行。如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL.</p>
<p>代码：</p><pre class="crayon-plain-tag">class Base { virtual dummy() {} };
class Derived : public Base {};

Base* b1 = new Derived;
Base* b2 = new Base;

Derived* d1 = dynamic_cast&lt;Derived *&gt;(b1); // succeeds
Derived* d2 = dynamic_cast&lt;Derived *&gt;(b2); // fails: returns 'NULL'</pre><p>如果一个引用类型执行了类型转换并且这个转换是不可能的，一个bad_cast的异常类型被抛出：</p>
<p>代码:</p><pre class="crayon-plain-tag">class Base { virtual dummy() {} };
class Derived : public Base { };

Base* b1 = new Derived;
Base* b2 = new Base;

Derived d1 = dynamic_cast&lt;Derived &amp;*&gt;(b1); // succeeds
Derived d2 = dynamic_cast&lt;Derived &amp;*&gt;(b2); // fails: exception thrown</pre><p></p>
<h3>4 const_cast</h3>
<p>这个转换类型操纵传递对象的const属性，或者是设置或者是移除：</p>
<p>代码:</p><pre class="crayon-plain-tag">class C {};
const C *a = new C;

C *b = const_cast&lt;C *&gt;(a);</pre><p>其它三种操作符是不能修改一个对象的常量性的。注意：&#8217;const_cast&#8217;也能改变一个类型的volatile qualifier。</p>
<h3>C++ 的四种强制转型形式每一种适用于特定的目的</h3>
<ul>
<li>dynamic_cast 主要用于执行“安全的向下转型（safe downcasting）”，也就是说，要确定一个对象是否是一个继承体系中的一个特定类型。它是唯一不能用旧风格语法执行的强制转型，也是唯一可能有重大运行时代价的强制转型。</li>
<li>static_cast 可以被用于强制隐型转换（例如，non-const 对象转型为 const 对象，int 转型为 double，等等），它还可以用于很多这样的转换的反向转换（例如，void* 指针转型为有类型指针，基类指针转型为派生类指针），但是它不能将一个 const 对象转型为 non-const 对象（只有 const_cast 能做到），它最接近于C-style的转换。</li>
<li>const_cast 一般用于强制消除对象的常量性。它是唯一能做到这一点的 C++ 风格的强制转型。</li>
<li>reinterpret_cast 是特意用于底层的强制转型，导致实现依赖（implementation-dependent）（就是说，不可移植）的结果，例如，将一个指针转型为一个整数。这样的强制转型在底层代码以外应该极为罕见。</li>
</ul>
<p><a href="http://blog.jobbole.com/107033/">C++ 的强制类型转换</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/107033/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Go net/http 超时机制完全手册</title>
		<link>http://blog.jobbole.com/107012/</link>
		<comments>http://blog.jobbole.com/107012/#respond</comments>
		<pubDate>Tue, 25 Oct 2016 04:00:06 +0000</pubDate>
		<dc:creator><![CDATA[ABOER]]></dc:creator>
				<category><![CDATA[IT技术]]></category>
		<category><![CDATA[Go]]></category>
		<category><![CDATA[HTTP]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=107012</guid>
		<description><![CDATA[<p>当用Go写HTTP的服务器和客户端的时候，超时处理总是最易犯错和最微妙的地方之一。错误可能来自很多地方，一个错误可能等待很长时间没有结果，直到网络故障或者进程挂起。HTTP是一个复杂的、多阶段(multi-stage)协议，所以没有一个放之四海而皆准的超时解决方案，比如一个流服务、一个JSON API和一个Comet服务对超时的需求都不相同， 往往默认值不是你想要的。</p><p><a href="http://blog.jobbole.com/107012/">Go net/http 超时机制完全手册</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p style="text-align: justify">当用Go写HTTP的服务器和客户端的时候，超时处理总是最易犯错和最微妙的地方之一。错误可能来自很多地方，一个错误可能等待很长时间没有结果，直到网络故障或者进程挂起。</p>
<p style="text-align: justify">HTTP是一个复杂的、多阶段(multi-stage)协议，所以没有一个放之四海而皆准的超时解决方案，比如一个流服务、一个JSON API和一个Comet服务对超时的需求都不相同， 往往默认值不是你想要的。</p>
<p style="text-align: justify">本文我将拆解需要超时设置的各个阶段，看看用什么不同的方式去处理它， 包括服务器端和客户端。</p>
<h3 id="SetDeadline" style="text-align: justify">SetDeadline</h3>
<p style="text-align: justify">首先，你需要了解Go实现超时的网络原语(primitive): <strong>Deadline</strong> (最后期限)。</p>
<p style="text-align: justify"><code>net.Conn</code>为Deadline提供了多个方法<code>Set[Read|Write]Deadline(time.Time)</code>。Deadline是一个绝对时间值，当到达这个时间的时候，所有的 I/O 操作都会失败，返回超时(timeout)错误。</p>
<p style="text-align: justify"><strong>Deadline不是超时</strong>(timeout)。一旦设置它们永久生效(或者直到下一次调用SetDeadline), 不管此时连接是否被使用和怎么用。所以如果想使用<code>SetDeadline</code>建立超时机制，你不得不每次在<code>Read/Write</code>操作之前调用它。</p>
<p style="text-align: justify">你可能不想自己调用<code>SetDeadline</code>, 而是让<code>net/http</code>代替你调用，所以你可以调用更高级的timeout方法。但是请记住，所有的超时的实现都是基于Deadline, 所以它们不会每次接收或者发送重新设置这个值(so they <strong>do NOT reset every time data is sent or received</strong>)。</p>
<blockquote><p>江南雨的指正：<br />
应该是由于“Deadline是一个绝对时间值”，不是真的超时机制，所以作者特别提醒，这个值不会自动重置的，需要每次手动设置。</p></blockquote>
<h3 id="服务器端超时设置" style="text-align: justify">服务器端超时设置</h3>
<p style="text-align: justify"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/e30d44a220da0eef0234821bc2c0cf91.png"><img class="alignnone size-full wp-image-107015" src="http://jbcdn2.b0.upaiyun.com/2016/10/e30d44a220da0eef0234821bc2c0cf91.png" alt="server-timeout" /></a></p>
<p style="text-align: justify">对于暴露在网上的服务器来说，为客户端连接设置超时至关重要，否则巨慢的或者隐失的客户端可能导致文件句柄无法释放，最终导致服务器出现下面的错误:</p>
<p></p><pre class="crayon-plain-tag">http: Accept error: accept tcp [::]:80: accept4: too many open files; retrying in 5ms</pre><p></p>
<p style="text-align: justify"><code>http.Server</code>有两个设置超时的方法: <code>ReadTimeout</code> 和 <code>and</code>WriteTimeout`。你可以显示地设置它们：</p>
<figure style="text-align: justify"></figure>
<p></p><pre class="crayon-plain-tag">srv := &amp;http.Server{  
    ReadTimeout: 5 * time.Second,
    WriteTimeout: 10 * time.Second,
}
log.Println(srv.ListenAndServe())</pre><p></p>
<p style="text-align: justify"><code>ReadTimeout</code>的时间计算是从连接被接受(accept)到request body完全被读取(如果你不读取body，那么时间截止到读完header为止)。它的内部实现是在<code>Accept</code>立即调用<code>SetReadDeadline</code>方法(代码行)。</p>
<figure style="text-align: justify"></figure>
<p></p><pre class="crayon-plain-tag">……
  if d := c.server.ReadTimeout; d != 0 {
	c.rwc.SetReadDeadline(time.Now().Add(d))
}
if d := c.server.WriteTimeout; d != 0 {
	c.rwc.SetWriteDeadline(time.Now().Add(d))
}
  ……</pre><p></p>
<p style="text-align: justify"><code>WriteTimeout</code>的时间计算正常是从request header的读取结束开始，到 response write结束为止 (也就是 ServeHTTP 方法的声明周期), 它是通过在<code>readRequest</code>方法结束的时候调用<code>SetWriteDeadline</code>实现的(代码行)。</p>
<figure style="text-align: justify"></figure>
<p></p><pre class="crayon-plain-tag">func (c *conn) readRequest(ctx context.Context) (w *response, err error) {
	if c.hijacked() {
		return nil, ErrHijacked
	}
	if d := c.server.ReadTimeout; d != 0 {
		c.rwc.SetReadDeadline(time.Now().Add(d))
	}
	if d := c.server.WriteTimeout; d != 0 {
		defer func() {
			c.rwc.SetWriteDeadline(time.Now().Add(d))
		}()
	}
  ……
}</pre><p></p>
<p style="text-align: justify">但是，当连接是HTTPS的时候，<code>SetWriteDeadline</code>会在<code>Accept</code>之后立即调用(代码)，所以它的时间计算也包括 TLS握手时的写的时间。 讨厌的是， 这就意味着(也只有这种情况) <code>WriteTimeout</code>设置的时间也包含读取Headerd到读取body第一个字节这段时间。</p>
<figure style="text-align: justify"></figure>
<p></p><pre class="crayon-plain-tag">if tlsConn, ok := c.rwc.(*tls.Conn); ok {
		if d := c.server.ReadTimeout; d != 0 {
			c.rwc.SetReadDeadline(time.Now().Add(d))
		}
		if d := c.server.WriteTimeout; d != 0 {
			c.rwc.SetWriteDeadline(time.Now().Add(d))
		}
    ……</pre><p></p>
<p style="text-align: justify">当你处理不可信的客户端和网络的时候，你应该同时设置读写超时，这样客户端就不会因为读慢或者写慢长久的持有这个连接了。</p>
<p style="text-align: justify">最后，还有一个<code>http.TimeoutHandler</code>方法。 它并不是Server参数，而是一个Handler包装函数，可以限制 <code>ServeHTTP</code>调用。它缓存response, 如果deadline超过了则发送 <em>504 Gateway Timeout</em> 错误。 注意这个功能在 1.6 中有问题，在1.6.2中改正了。</p>
<h4 id="http-ListenAndServe_的错误" style="text-align: justify">http.ListenAndServe 的错误</h4>
<p style="text-align: justify">顺便提一句，<code>net/http</code>包下的封装的绕过<code>http.Server</code>的函数<code>http.ListenAndServe</code>, <code>http.ListenAndServeTLS</code> 和 <code>http.Serve</code>并不适合实现互联网的服务器。这些函数让超时设置默认不启用，并且你没有办法设置启用超时处理。所以如果你使用它们，你会很快发现连接泄漏，太多的文件句柄。我犯过这种错误至少五六次。</p>
<p style="text-align: justify">取而代之，你应该创建一个<code>http.Server</code>示例，设置<code>ReadTimeout</code>和<code>WriteTimeout</code>,像上面的例子中一样使用相应的方法。</p>
<h4 id="关于流" style="text-align: justify">关于流</h4>
<p style="text-align: justify">令人心塞的是， 没有办法从<code>ServeHTTP</code>中访问底层的<code>net.Conn</code>，所以提供流服务强制不去设置<code>WriteTimeout</code>（这也可能是为什么这些值的默认值总为0）。如果无法访问<code>net.Conn</code>就不能在每次<code>Write</code>的时候调用<code>SetWriteDeadline</code>来实现一个正确的idle timeout。</p>
<p style="text-align: justify">而且，也没有办法取消一个阻塞的<code>ResponseWriter.Write</code>，因为<code>ResponseWriter.Close</code>没有文档指出它可以取消一个阻塞并发写。也没有办法使用Timer创建以俄国手工的timeout 杯具就是流服务器不能对于慢读的客户端进行防护。我提交的了一个［bug](<a href="https://github.com/golang/go/issues/16100)%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E5%8F%8D%E9%A6%88%E3%80%82" target="_blank" rel="external">https://github.com/golang/go/issues/16100)，欢迎大家反馈。</a></p>
<blockquote><p><em>编者按</em>: 作者此处的说法是有问题的，可以通过Hijack获取net.Conn,既然可以可以获取net.Conn,我们就可以调用它的SetWriteDeadline方法。代码例子如下：</p></blockquote>
<figure style="text-align: justify"></figure>
<p></p><pre class="crayon-plain-tag">package main
import (
	"fmt"
	"log"
	"net/http"
)
func main() {
	http.HandleFunc("/hijack", func(w http.ResponseWriter, r *http.Request) {
		hj, ok := w.(http.Hijacker)
		if !ok {
			http.Error(w, "webserver doesn't support hijacking", http.StatusInternalServerError)
			return
		}
		conn, bufrw, err := hj.Hijack()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		// Don't forget to close the connection:
		defer conn.Close()
		conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
		bufrw.WriteString("Now we're speaking raw TCP. Say hi: ")
		bufrw.Flush()
		s, err := bufrw.ReadString('\n')
		if err != nil {
			log.Printf("error reading string: %v", err)
			return
		}
		fmt.Fprintf(bufrw, "You said: %q\nBye.\n", s)
		bufrw.Flush()
	})
}</pre><p></p>
<h3 id="客户端超时设置" style="text-align: justify">客户端超时设置</h3>
<p style="text-align: justify"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/1622bc9fc9309dd494f313f360e39182.png"><img class="alignnone size-full wp-image-107014" src="http://jbcdn2.b0.upaiyun.com/2016/10/1622bc9fc9309dd494f313f360e39182.png" alt="client-timeout" /></a></p>
<p style="text-align: justify">Client端的超时设置说复杂也复杂，说简单也简单，看你怎么用了，最重要的就是不要有资源泄漏的情况或者程序被卡住。</p>
<p style="text-align: justify">最简单的方式就是使用<code>http.Client</code>的 <code>Timeout</code>字段。 它的时间计算包括从连接(Dial)到读完response body。</p>
<figure style="text-align: justify"></figure>
<p></p><pre class="crayon-plain-tag">c := &amp;http.Client{  
    Timeout: 15 * time.Second,
}
resp, err := c.Get("https://blog.filippo.io/")</pre><p></p>
<p style="text-align: justify">就像服务器端一样，<code>http.GET</code>使用Client的时候也没有超时设置,所以在互联网上使用也很危险。</p>
<p style="text-align: justify">有一些更细粒度的超时控制：</p>
<ul style="text-align: justify">
<li><code>net.Dialer.Timeout</code> 限制建立TCP连接的时间</li>
<li><code>http.Transport.TLSHandshakeTimeout</code> 限制 TLS握手的时间</li>
<li><code>http.Transport.ResponseHeaderTimeout</code> 限制读取response header的时间</li>
<li><code>http.Transport.ExpectContinueTimeout</code> 限制client在发送包含 <code>Expect: 100-continue</code>的header到收到继续发送body的response之间的时间等待。注意在1.6中设置这个值会禁用HTTP/2(<code>DefaultTransport</code>自1.6.2起是个特例)</li>
</ul>
<figure style="text-align: justify"></figure>
<p></p><pre class="crayon-plain-tag">c := &amp;http.Client{  
    Transport: &amp;Transport{
        Dial: (&amp;net.Dialer{
                Timeout:   30 * time.Second,
                KeepAlive: 30 * time.Second,
        }).Dial,
        TLSHandshakeTimeout:   10 * time.Second,
        ResponseHeaderTimeout: 10 * time.Second,
        ExpectContinueTimeout: 1 * time.Second,
    }
}</pre><p></p>
<p style="text-align: justify">如我所讲，没有办法限制发送request的时间。读取response body (原文是读取request body，按照理解应该是读取response可以手工控制)的时间花费可以手工的通过一个<code>time.Timer</code>来实现, 读取发生在调用Client.Do之后（详见下一节）。</p>
<p style="text-align: justify">最后将一点，在Go 1.7中，增加了一个<code>http.Transport.IdleConnTimeout</code>， 它不控制client request的阻塞阶段，但是可以控制连接池中一个连接可以idle多长时间。</p>
<p style="text-align: justify">注意一个Client缺省的可以执行 <em>redirect</em>。<code>http.Client.Timeout</code>包含所有的<code>redirect</code>，而细粒度的超时控制参数只针对单次请求有效， 因为<code>http.Transport</code>是一个底层的类型，没有<code>redirect</code>的概念。</p>
<h3 id="Cancel_和_Context" style="text-align: justify">Cancel 和 Context</h3>
<p style="text-align: justify"><code>net/http</code>提供了两种方式取消一个client的请求: <code>Request.Cancel</code>以及Go 1.7新加的<code>Context</code>。</p>
<p style="text-align: justify"><code>Request.Cancel</code>是一个可选的channel, 当设置这个值并且close它的时候，request就会终止，就好像超时了一样(实际它们的实现是一样的，在写本文的时候我还发现一个1.7 的 一个<a href="https://github.com/golang/go/issues/16094" target="_blank" rel="external">bug</a>, 所有的cancel操作返回的错误还是timeout error )。</p>
<p style="text-align: justify">我们可以使用<code>Request.Cancel</code>和<code>time.Timer</code>来构建一个细粒度的超时控制，允许读取流数据的时候推迟deadline:</p>
<figure style="text-align: justify"></figure>
<p></p><pre class="crayon-plain-tag">package main
import (  
    "io"
    "io/ioutil"
    "log"
    "net/http"
    "time"
)
func main() {  
    c := make(chan struct{})
    timer := time.AfterFunc(5*time.Second, func() {
        close(c)
    })
        // Serve 256 bytes every second.
    req, err := http.NewRequest("GET", "http://httpbin.org/range/2048?duration=8&amp;chunk_size=256", nil)
    if err != nil {
        log.Fatal(err)
    }
    req.Cancel = c
    log.Println("Sending request...")
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        log.Fatal(err)
    }
    defer resp.Body.Close()
    log.Println("Reading body...")
    for {
        timer.Reset(2 * time.Second)
                // Try instead: timer.Reset(50 * time.Millisecond)
        _, err = io.CopyN(ioutil.Discard, resp.Body, 256)
        if err == io.EOF {
            break
        } else if err != nil {
            log.Fatal(err)
        }
    }
}</pre><p></p>
<p style="text-align: justify">上面的例子中我们为Do方法执行阶段设置5秒的超时，但是我们至少花费8秒执行8次才能读完所欲的body，每一次设置2秒的超时。我们可以为流 API这样处理避免程序死在那里。 如果超过两秒我们没有从服务器读取到数据， io.CopyN会返回<code>net/http: request canceled</code>错误。</p>
<p style="text-align: justify">在1.7中， context包升级了，进入到标准库中。Context有很多值得学习的功能，但是对于本文介绍的内容来讲，你只需直到它可以用来替换和扔掉<code>Request.Cancel</code>。</p>
<p style="text-align: justify">用Context取消请求很简单，我们只需得到一个新的Context和它的cancel()函数，这是通过context.WithCancel方法得到的，然后创建一个request并使用<code>Request.WithContext</code>绑定它。当我们想取消这个请求是，我们调用<code>cancel()</code>取消这个Context:</p>
<figure style="text-align: justify"></figure>
<p></p><pre class="crayon-plain-tag">ctx, cancel := context.WithCancel(context.TODO())  
timer := time.AfterFunc(5*time.Second, func() {  
    cancel()
})
req, err := http.NewRequest("GET", "http://httpbin.org/range/2048?duration=8&amp;chunk_size=256", nil)  
if err != nil {  
    log.Fatal(err)
}
req = req.WithContext(ctx)</pre><p></p>
<p style="text-align: justify">Context好处还在于如果parent context被取消的时候(在<code>context.WithCancel</code>调用的时候传递进来的)，子context也会取消， 命令会进行传递。</p>
<p><a href="http://blog.jobbole.com/107012/">Go net/http 超时机制完全手册</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/107012/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>6 个月才解决了这个小 Bug</title>
		<link>http://blog.jobbole.com/107030/</link>
		<comments>http://blog.jobbole.com/107030/#comments</comments>
		<pubDate>Tue, 25 Oct 2016 03:48:45 +0000</pubDate>
		<dc:creator><![CDATA[至秦]]></dc:creator>
				<category><![CDATA[开发]]></category>
		<category><![CDATA[Bug]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=107030</guid>
		<description><![CDATA[<p>我曾经为一家美国著名的国防承包商工作过。我花费了 6 个月的时间去查找一个错误的字母，而它是一个比我多 26 年工作经验的工程师所犯的输入错误。</p><p><a href="http://blog.jobbole.com/107030/">6 个月才解决了这个小 Bug</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p>我曾经为一家美国著名的国防承包商工作过。我很高兴我做到了，因为它是我一直的梦想；但我也很高兴有机会继续前进。我学到了很多，遇到超多了不起的家伙，而且只要我活着，就永远不会缩写另外一个变量。</p>
<p><img id="pic" class="aligncenter" src="http://ww2.sinaimg.cn/large/63918611gw1f94atklyhej20hs0b2ta6.jpg" /></p>
<p style="text-align: center;"><em>（图文无关。F-117 夜鹰隐形战机，图来自维基百科）</em></p>
<p>我效力过一个隐形飞机的项目，这里不提它的名字，它主要负责制造雷达接收器。你可以能会问，“为什么隐形飞机还需要雷达接收器？”这主要有两个原因。这些接收器是定制的，专门用来接收和识别地理位置以及敌方系统发射雷达脉冲的国籍。首先，知道敌方雷达的地理位置，可以帮助你避免意外飞过他们的上空（如果你的影子飞过敌方空军基地上空，却没有被雷达发现，那是极好的）。第二，它让你分析敌方在哪里寻找你（比如在一个山头上出现了一个俄国的防空导弹基地，上个月还没有呢，那你就知道一定有些东西在上面）。</p>
<p>当接收器在测试实验室的时候，你经常会看到 20~30 磅的精美的航空级铝，里面塞满了 10~20个 定制的电子卡，上面运行着价值 50~100 万美元的软件。移动接收器很容易，绝大多数我在实验室里处理的，都是空军部队在使用中遇到某些问题的。本质上，99.9% 的这些问题都是电子问题，我们不得不欺骗这个盒子，让它认为自己飞在空中，并接受敌方的雷达脉冲。测试仪器和软件在当初采购时，可能是很先进的，在合同获准后都维持不变。然而，因为它们是上世纪 90 年代获准的，你可以想象我们20年后还不得不处理这些遗物。以 MHz 计量的古老 CPU，比我还要老的操作系统，软件的用户友好特性根本无从谈起。我工作的一部分是执行新的合同，负责将升级原有测试仪器以及在上面运行的软件。接下来，有趣的事情发生了。</p>
<p>这项宏大的任务有很多层，我负责的一层是在同一个接收器上运行新旧两个测试，看结果有什么不同，找到软件的问题，然后修正它。因为有很多小问题要处理，所以事情进展地相当缓慢但是还算稳定，但是 SlowPOP 给我留下的印象却挥之不去。SlowPOP，也被称为“慢上升时间的脉冲叠加”，这项测试用来保证在接收到两个叠加的雷达脉冲，而且脉冲的上升、下降时间比正常时间要慢很多的情况下，接收器还能正常工作。这些细节不但枯燥而且还属于机密，所以可以这么说，结果相当糟糕。输入参数稍有调整，测试就可以通过……差不多是这样……但是这仍旧不太正常，后面调整的参数和原始参数并不是很接近，这让我很不舒服。</p>
<p>我不停地重启，重新校准，重新安装（软件），重新测试、测试、不停地测试。</p>
<p>我不断地询问，调查，请求，追问，推测。</p>
<p>随后几个月，我们发布了其它可以通过测试的版本。</p>
<p>有趣的是，每当我问到 WaveGenAPI 函数的时候，每个人都说“那个函数不可能有问题，其他 80% 的测试都在使用它，而且它也正常工作一年多了。”</p>
<p>最后在检查所有可能后，我知道必须要检查 WaveGenAPI 了。</p>
<p>当我研究 WaveGenAPI 函数代码时，经过几天的努力，我找到一些线索。有一行代码看上去不太对。它添加了一堆术语，其中有一个术语看上去不太对。我请 WaveGenAPI 的作者（他有令我羡慕的 26 年经验）下到实验室，和我一起看结果。他沉默地盯着那行代码差不多有半个小时，只问了这个问题的基本信息，包含了基本的检查和可能性。最终他只说了一句“做得好”，然后我们握手，他就离开了。</p>
<p>问题找到了：<strong>一个文件 → 一行代码 → 一个术语 → 一个变量 → 一个字母</strong></p>
<p>当时，这位资深程序员接受的训练就是要限定变量名的长度，他在实际工作中使用的变量名长度都不会超过 8 个字符。在这个案例中，有问题变量的含义是脉冲“下降沿十分之一高度的时间”。这个术语应该缩写成 “<span style="color: #ff0000;">Ttpfe</span>”，但是他错误地把它命名成“<span style="color: #ff0000;">Ttpre</span>”，而它却正好代表相反的含义，即“上升沿”。“<span style="color: #ff0000;">Ttpre</span>”这个术语也存在了，所以这个拼写错误才不会造成“undefined”错误。而且除了 SlowPOP 以外，所有测试的时间差异都在1个皮秒内（译注：1皮秒等于百万分之一微秒）。发现和修订这个错误，是对我六个月工作的最高嘉奖，并且是迄今为止我职业生涯中找到最让人满意的 bug。</p>
<p>这就是为什么，只要我活着，就永远不会缩写变量名。</p>
<p>简而言之，我花费了 6 个月的时间去查找一个错误的字母，而它是一个比我多 26 年工作经验的工程师所犯的输入错误。</p>
<p><a href="http://blog.jobbole.com/107030/">6 个月才解决了这个小 Bug</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/107030/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>全栈必备：Git</title>
		<link>http://blog.jobbole.com/107027/</link>
		<comments>http://blog.jobbole.com/107027/#respond</comments>
		<pubDate>Tue, 25 Oct 2016 01:44:51 +0000</pubDate>
		<dc:creator><![CDATA[(●'◡'●)]]></dc:creator>
				<category><![CDATA[IT技术]]></category>
		<category><![CDATA[Git]]></category>
		<category><![CDATA[全栈]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=107027</guid>
		<description><![CDATA[<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。每一个GIT克隆都是一个完整的文件库，含有全部历史记录和修订追踪能力。其最大特色就是“分支”及“合并”操作快速、简便。</p><p><a href="http://blog.jobbole.com/107027/">全栈必备：Git</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<div>
<h1 id="为什么使用git">为什么使用Git</h1>
<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。大神就是大神，在开发了Linux之后，Git 是又一抗鼎之作。这是唯一的理由么？</p>
<h2 id="git在软件开发中位置配置管理scm">Git在软件开发中位置——配置管理SCM</h2>
<p>Software configuration management (SCM, or just plain CM) is an organizational framework — that is, a discipline — for managing the evolution of computer systems throughout all stages of systems development.</p>
<p>软件配置管理:通过执行版本控制、变更控制的规程，以及使用合适的配置管理软件，来保证所有配置资源的完整性和可跟踪性。配置管理是对工作成果的一种有效保护。没有软件配置管理，最大的麻烦是工作成果无法回溯。</p>
<h3 id="配置管理的内容和目标">配置管理的内容和目标</h3>
<p>配置管理的内容：</p>
<p>一类是属于产品的组成部分，例如需求文档、设计文档、源代码、测试用例等等；<br />
另一类是在管理过程中产生的文档，例如各种计划、报告等</p>
<p>软件配置管理是在贯穿整个软件生命周期中建立和维护项目产品的完整性。它的基本目标包括：<br />
1. 软件配置管理的各项工作是有计划进行的。<br />
2. 被选择的项目产品得到识别，控制并且可以被相关人员获取。<br />
3. 已识别出的项目产品的更改得到控制。<br />
4. 使相关组别和个人及时了解软件基准的状态和内容。</p>
<h3 id="配置管理的主要任务">配置管理的主要任务</h3>
<p>软件配置管理的主要任务也就归结为以下几条：<br />
（1）制定项目的配置计划；<br />
（2）对配置项进行标识；<br />
（3）对配置项进行版本控制；<br />
（4）对配置项进行变更控制；<br />
（5）定期进行配置审计；<br />
（6）向相关人员报告配置的状态。</p>
<h2 id="版本控制">版本控制</h2>
<p>版本控制是软件配置管理的核心功能。所有位于配置资源库中的元素都应自动予以版本的标识，并保证版本命名的唯一性。版本在生成过程中，自动依照设定的使用模型自动分支、演进。</p>
<p>版本控制(Revision control)确保由不同人所编辑的同一档案都得到更新。</p>
<h3 id="版本控制中的基本概念">版本控制中的基本概念</h3>
<p>1）签入，提交，检出<br />
2）冲突，解决，合并<br />
3）分支，版本<br />
4）锁定，hook</p>
<h3 id="常见的版本控制工具">常见的版本控制工具</h3>
<p>作为一个老码农，枚举一下曾经使用过的版本控制工具。<br />
1. VSS： visual source safe, 微软的东东，97年写VC程序时使用，人多的时候性能较差，不知道现在的升级版怎样了<br />
2. clearcase： 99年开发Unix 上分布式式应用时使用，功能强大，不只限于版本控制，有钱的大团队才去用<br />
3. CVS: 02年在互联网热潮的时候使用，开源产品，当时“Copy-Modify-Merge”开发模型眼前一亮。<br />
4. SVN：曾经的挚爱，在曾工作的合资公司使用，权限管理和分支合并等方面做的很出色，并在多个公司推广使用。还记得TortoiseSVN么?那只可爱的小乌龟。<br />
5. perforce:是一款具有轻便快速的SCM工具、真正的客户端/服务器系统等特点的商业软件。高通内部使用的版本管理工具。确实不错。<br />
6. git：现在的最爱……<br />
比较一下cvs,svn,和git：</p>
<p><img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/cd2116ae2f6f663827744ae79c3c04ac.png" alt="开源版本控制工具比较" /></p>
<h1 id="git-简要">Git 简要</h1>
<p>GIT 是一款免费的、开源的、分布式的版本控制系统。每一个GIT克隆都是一个完整的文件库，含有全部历史记录和修订追踪能力。其最大特色就是“分支”及“合并”操作快速、简便。支持离线工作，GIT是整个项目范围的原子提交，而且GIT中的每个工作树都包含一个具有完整项目历史的仓库。</p>
<h2 id="核心特点">核心特点：</h2>
<ol>
<li>Git 底层自行维护的存储文件系统：存储的是文件快照，即整个文件内容，并保存指向快照的索引</li>
<li>去中心化的分布式控制</li>
</ol>
<h2 id="优缺点">优缺点：</h2>
<p>优点：</p>
<ul>
<li>适合分布式开发，强调个体。</li>
<li>公共服务器压力和数据量都不会太大， 速度快、灵活。</li>
<li>任意两个开发者之间可以很容易的解决冲突。</li>
<li>离线工作。</li>
</ul>
<p>缺点：</p>
<ul>
<li>学习周期相对而言比较长。</li>
<li>不符合常规思维。</li>
<li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li>
</ul>
<h1 id="git-原理">Git 原理</h1>
<h2 id="git的目录结构">Git的目录结构</h2>
<p>不论通过git init 还是克隆下来的git 仓库，都有如下的目录结构：<br />
<img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/f9a8217d6b0eb4d523298fcfefe7e86b.png" alt="这里写图片描述" /></p>
<p>主要目录结构描述见下表：</p>
<table>
<tbody>
<tr>
<th>子目录名</th>
<th>简要描述</th>
</tr>
<tr>
<th>branches</th>
<th>Git 项目分支信息，新版 Git 已经不再使用该目录</th>
</tr>
<tr>
<th>config</th>
<th>Git 项目配置信息</th>
</tr>
<tr>
<th>description</th>
<th>Git 项目描述信息</th>
</tr>
<tr>
<th>HEAD</th>
<th>指向 Git 项目当前分支的头指针</th>
</tr>
<tr>
<th>hooks</th>
<th>默认的”hooks”脚本，被特定事件发生前后触发。</th>
</tr>
<tr>
<th>info</th>
<th>里面含一个 exclude 文件，指 Git 项目要忽略的文件。</th>
</tr>
<tr>
<th>objects</th>
<th>Git 的数据对象，包括：commits, trees, blobs, tags。</th>
</tr>
<tr>
<th>refs</th>
<th>指向所有 Git 项目分支的指针</th>
</tr>
</tbody>
</table>
<p>所有的分支指针保存在 .git/refs/heads 目录下，HEAD 在 .git/HEAD 目录下，标签在 .git/refs/tags 目录下。</p>
<h2 id="快照">快照</h2>
<p>例如： 一个工程中有两个文件A和B， 有3个版本:<br />
V1.0 A和B，V1.5 A1和B，V2.0 A1和B1<br />
在Git 的实际存储中实际存了3个快照 4个文件。</p>
<p>Git对文件进行 SHA-1 计算作为文件的唯一ID，并校验了文件完整性。</p>
<p>SHA-1 算法将文件中的内容通过计算生成一个 40 位的 Hash 值。SHA-1 算法的特点：<br />
由文件内容计算出的 Hash 值；Hash 值相同，文件内容相同。<br />
<img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/7bc8f6e28b47f52ff053b07896f405de.png" alt="这里写图片描述" /></p>
<p>使用 SHA-1 的前两位创建了文件夹，剩下的 38 位为文件名。</p>
<p>这些 Obj 文件，其实分为四种类型，分别是 Blob、Tree、Commit、Tag。</p>
<h3 id="blob">Blob</h3>
<p>用来存放项目文件的内容，但是不包括文件的路径、名字、格式等其它描述信息。项目的任意文件的任意版本都是以 Blob 的形式存放的。</p>
<h3 id="tree">Tree</h3>
<p>Tree 用来表示目录。我们知道项目就是一个目录，目录中有文件、有子目录。因此 Tree 中有 Blob、子 Tree，且都是使用 SHA-1值引用的。这是与目录对应的。从顶层的 Tree 纵览整个树状的结构，叶子结点就是 Blob，表示文件的内容，非叶子结点表示项目的目录，顶层的 Tree 对象就代表了当前项目的快照。</p>
<h3 id="commit">Commit</h3>
<p>表示一次提交，有 Parent 字段，用来引用父提交。指向了一个顶层 Tree，表示了项目的快照，还有一些其它的信息，比如上一个提交 Committer、Author、Message 等信息。</p>
<h2 id="存储区">存储区</h2>
<p>Git中有4个类型的存储区：远程仓库，工作区，本地仓库和缓存区。</p>
<p>暂存区的好处：</p>
<ol>
<li>为了能够实现部分提交</li>
<li>为了不在工作区创建状态文件、会污染工作区。</li>
<li>暂存区记录文件的修改时间等信息，提高文件比较的效率。<br />
暂存区是用来构建项目快照的区域。暂存区是一个文件，路径为： .Git/index</li>
</ol>
<p><img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/41dd63ef03554bba5d9eebea73503ab4.png" alt="暂存区的样子" /></p>
<p>它是一个二进制文件，第四列是文件名，第三列是文件的冲突状态，第二列指的是文件的 Blob。</p>
<p>Commit 命令，将暂存区的内容永久保存到本地仓库。提交时 Git 会使用暂存区的这些信息生成 Tree 对象，也就是项目快照，永久保存到数据库中。</p>
<p>文件的状态可以分为两类。一类是暂存区与本地仓库比较得出的状态，另一类是工作区与暂存区比较得出的状态。为什么要分成两类的愿意也很简单，因为第一类状态在提交时，会直接写入本地仓库。而第二种则不会。一个文件可以同时拥有两种状态。</p>
<h2 id="分支">分支</h2>
<p>分支的目的是让我们可以并行的进行开发。 .Git/HEAD 文件，它保存了当前的分支。</p>
<p><img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/ffd69c1076c063dfb6ef048884b4c1f6.png" alt="分支简要" /></p>
<p>分支指向了一次提交，也是 Git 中的分支为什么这么轻量的原因。</p>
<p>因为分支就是指向了一个 Commit 的指针，当提交新的 Commit，这个分支的指向只需要跟着更新就可以了，而创建分支仅仅是创建一个指针。</p>
<h1 id="git-必备技能">Git 必备技能</h1>
<h2 id="常见命令速查">常见命令速查</h2>
<p><img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/0435d1c7fdf7de0851f6c87bf12209a0.png" alt="常见命令速查表" /></p>
<h2 id="git-add-和-git-commit">git add 和 git commit</h2>
<p>Add 操作是将修改保存到暂存区，Commit 是将暂存区的内容永久保存到本地仓库。</p>
<p>每当将修改的文件加入到暂存区，Git 都会根据文件的内容计算出 SHA-1，并将内容转换成 Blob，写入数据库。然后使用 SHA-1 值更新该列表中的文件项。</p>
<p>在暂存区的文件列表中，每一个文件名，都会对应一个 SHA-1 值，用于指向文件的实际内容。最后提交的那一刻，Git 会将这个列表信息转换为项目的快照，也就是 Tree 对象。写入数据库，并再构建一个 Commit 对象，写入数据库。然后更新分支指向。</p>
<h2 id="分支合并-merge-和rebase">分支合并: merge 和rebase</h2>
<p>冲突的状态</p>
<ul>
<li>DELETED_BY_THEM;</li>
<li>DELETED_BY_US;</li>
<li>BOTH_ADDED;</li>
<li>BOTH_MODIFIED</li>
</ul>
<p>遇到不可自动合并冲突时，Git 会将这些状态写入到暂存区。</p>
<h3 id="merge">merge</h3>
<p>在解决完冲突后，我们可以将修改的内容提交为一个新的提交。这就是 Merge。<br />
Merge 之后仍可以做出新的提交。</p>
<p><img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/4a3e10e7208546ca8d9c1d9e34fd44fa.png" alt="merge" /></p>
<h3 id="rebase">rebase</h3>
<p>Rebase 会把从 Merge Base 以来的所有提交，以补丁的形式一个一个重新达到目标分支上。这使得目标分支合并该分支的时候会直接 Fast Forward，即不会产生任何冲突。</p>
<p><img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/4fc871d03fbab902c3f8f04da1e5acbd.png" alt="rebase" /></p>
<p>Rebase 主要在 .Git/Rebase-Merge 下生成了两个文件，分别为 Git-Rebase-todo 和 Done 文件，Git-Rebase-todo 存放了 Rebase 将要操作的 Commit。而 Done 存放正在操作或已经操作完毕的 Commit。</p>
<p>Rebase 的一个缺点，那就是修改了分支的历史提交。如果已经将分支推送到了远程仓库，会导致无法将修改后的分支推送上去，必须使用 -f 参数（Force）强行推送。</p>
<p>所以使用 Rebase 最好不要在公共分支上进行操作。</p>
<h3 id="checkout">checkout</h3>
<p>经常用来切换分支、或者切换到某一次提交。</p>
<p>Checkout 找到目标提交（Commit），目标提交中的快照也就是 Tree 对象就是我们要检出的项目版本。</p>
<p>Checkout 首先根据Tree生成暂存区的内容，再根据 Tree 与其包含的 Blob 转换成我们的项目文件。然后修改 HEAD 的指向，表示切换分支。</p>
<p>Checkout 并没有修改提交的历史记录。只是将对应版本的项目内容提取出来。</p>
<h3 id="revert">revert</h3>
<p>revert 实现了反向提交，就是旧版本添加了的内容，要在新版本中删除；旧版本中删除了的内容，要在新版本中添加。这在分支已经推送到远程仓库的情境下非常有用。</p>
<p>Revert 也不会修改历史提交记录，实际的操作相当于是检出目标提交的项目快照到工作区与暂存区，然后用一个新的提交完成版本的“回退”。</p>
<h3 id="reset">reset</h3>
<p>在当前分支进行版本的“回退”，Reset 是会修改历史提交记录的。</p>
<p>Reset 常用的选项有三个，分别是 —Soft, —Mixed, —Hard。他们的作用域依次增大。<br />
Soft 会仅仅修改分支指向。而不修改工作区与暂存区的内容，<br />
Mixed 比 Soft 的作用域多了一个 暂存区。实际上 Mixed 选项与 Soft 只差了一个 Add 操作。<br />
Hard 会比 Mixed作用域又多了一个工作区。</p>
<p>注意：在丢失后可以使用 Git Reset –Hard ORIG_HEAD 立即恢复，或者使用 reflog 命令查看之前分支的引用</p>
<h3 id="stash">stash</h3>
<p>有时，在一个分支上做了一些工作，修改了很多代码，而这时需要切换到另一个分支干点别的事。但又不想将只做了一半的工作提交。</p>
<p>Stash 将工作区与暂存区中的内容做一个提交，保存起来，然后使用Reset Hard 选项恢复工作区与暂存区内容。我们可以随时使用 Stash Apply 将修改应用回来。</p>
<p>Stash 实现思路将我们的修改提交到本地仓库，使用特殊的分支指针（.Git/refs/Stash）引用该提交，然后在恢复的时候，将该提交恢复即可。</p>
<h1 id="git-典型实践">Git 典型实践</h1>
<p>一个典型的git 并行开发的流程模型如下：</p>
<p><img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/2e370596c8095239140bc0e01c318835.png" alt="git 典型实践" /></p>
<h2 id="主要分支">主要分支</h2>
<p>把origin/master作为主要分支，源码的HEAD总是表示production-ready(可随时部署)状态。<br />
<img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/40b02fc5d50d311d07f458bfb5333607.png" alt="master和develop" /></p>
<p>origin/develop上的代码是为下一次的代码发布准备的。每日构建也是基于此分支。<br />
当develop分支达到了一个稳定状态并准备发布时，所有的改变都要合并到master分支，并标上版本号。</p>
<h2 id="辅助分支">辅助分支</h2>
<h3 id="feature-branches">Feature branches</h3>
<p>继承与合并都与develop 分支相关，用来开发新特性的(短期，远期都可以)。<br />
<img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/db0a43d594b876ec3e6025a3981c5b80.png" alt="feature和develop" /></p>
<p>当要创建一个新特性时，从develop分支上再创建一个 Feature branch。<br />
<code>$ git checkout -b myfeature develop</code><br />
合并feature 到develop</p><pre class="crayon-plain-tag">$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff myfeature
Updating ea1b82a..05e9557 (Summary of changes)
$ git branch -d myfeature
Deleted branch myfeature (was 05e9557).
$ git push origin develop</pre><p><img title="" src="http://jbcdn2.b0.upaiyun.com/2016/10/99890ae5520ffbab91b173bafff34466.png" alt="merge without FF" /></p>
<h3 id="release-branches">Release branches</h3>
<p>继承分支: develop<br />
合并分支：develop 和 master<br />
命名规范：release-*</p>
<h4 id="创建一个release-分支">创建一个release 分支</h4>
<p>Release branch是通过develop分支而创建.</p><pre class="crayon-plain-tag">$ git checkout -b release-1.2 develop    
Switched to a new branch "release-1.2"

$ ./bump-version.sh 1.2
Files modified successfully, version bumped to 1.2.

$ git commit -a -m "Bumped version number to 1.2"
[release-1.2 74d9424] Bumped version number to 1.2
1 files changed, 1 insertions(+), 1 deletions(-)</pre><p></p>
<h4 id="完成一个release-分支">完成一个release 分支</h4>
<p>当release branch已经准备就绪，需要做几件事。</p>
<ol>
<li>release分支被合并到master分支上(每一个提交到master上的commit都是一个新版 本，切记)。</li>
<li>master上的commit都要添加tag，方便将来查看和回滚。</li>
<li>release上所做的修改必须合并到develop分支上，保证bug已被修补。<br />
前两个步骤：</li>
</ol>
<p></p><pre class="crayon-plain-tag">$ git checkout master
Switched to branch 'master'
$ git merge --no-ff release-1.2
Merge made by recursive.
(Summary of changes)
$ git tag -a 1.2</pre><p>为了把release上的改变保存到develop，需要合并到develop。</p><pre class="crayon-plain-tag">$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff release-1.2
Merge made by recursive.
(Summary of changes)</pre><p>这个步骤可能会导致冲突，如果这样的话，解决冲突，然后再提交。<br />
最后，可以删除release 分支。</p><pre class="crayon-plain-tag">$ git branch -d release-1.2
Deleted branch release-1.2 (was ff452fe).</pre><p></p>
<h3 id="hotfix-branches">Hotfix branches</h3>
<p>继承分支: master<br />
合并分支：develop 和 master<br />
命名规范：hotfix-*<br />
运行过程中发现了bug，就必须快速解决，这时就可以创建一个Hotfix branch，解决完后合并到master分支上。好处是开发人员可以继续工作，有专人来负责搞定这个bug。</p>
<h4 id="创建hotfix分支">创建hotfix分支</h4>
<p></p><pre class="crayon-plain-tag">$ git checkout -b hotfix-1.2.1 master
Switched to a new branch "hotfix-1.2.1"
$ ./bump-version.sh 1.2.1
Files modified successfully, version bumped to 1.2.1.
$ git commit -a -m "Bumped version number to 1.2.1"
[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1
1 files changed, 1 insertions(+), 1 deletions(-)</pre><p></p>
<h4 id="fix-bug-解决问题">fix bug, 解决问题</h4>
<p>需要一次或几次commit</p><pre class="crayon-plain-tag">$ git commit -m "Fixed severe production problem"
[hotfix-1.2.1 abbe5d6] Fixed severe production problem
5 files changed, 32 insertions(+), 17 deletions(-)</pre><p></p>
<h3 id="完成hotfix-branch">完成Hotfix branch</h3>
<p>当结束时，bugfix要被合并到master，同时也要合并到develop，保证下个版本发布时该bug已被修复。这跟release branch完成时一样。<br />
首先更新master和tag release</p><pre class="crayon-plain-tag">$ git checkout master
Switched to branch 'master'
$ git merge --no-ff hotfix-1.2.1
Merge made by recursive.
(Summary of changes)
$ git tag -a 1.2.1</pre><p>接下来与develop合并</p><pre class="crayon-plain-tag">$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff hotfix-1.2.1
Merge made by recursive.
(Summary of changes)</pre><p>有一个例外，就是当一个release branch存在时，bugfix要被合并到release而不是develop，因为release最终会被合并到develop。</p>
<h4 id="最后移除branch">最后移除branch</h4>
<p></p><pre class="crayon-plain-tag">$ git branch -d hotfix-1.2.1 
Deleted branch hotfix-1.2.1 (was abbe5d6).</pre><p></p>
<h1 id="总结">总结</h1>
<p>了解Git 在软件工程及敏捷开发中的地位，明白git与其他版本控制工具之间的区别，掌握Git 工作的基本原理和必备操作，复杂问题可以查找git的相关命令，应用git开发的流程模型，让Git 成为我们的真正利器。</p>
<p>参考资料：<br />
1）<a href="http://nvie.com/posts/a-successful-git-branching-model/">http://nvie.com/posts/a-successful-git-branching-model/</a><br />
2）<a href="https://community.qingcloud.com/topic/457/%E6%8A%80%E6%9C%AF%E5%9F%B9%E8%AE%AD-git-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E4%B9%88/2">https://community.qingcloud.com/topic/457/%E6%8A%80%E6%9C%AF%E5%9F%B9%E8%AE%AD-git-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E4%B9%88/2</a></p>
</div>
<p><a href="http://blog.jobbole.com/107027/">全栈必备：Git</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/107027/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>后端成长之路：从菜鸟到架构</title>
		<link>http://blog.jobbole.com/107025/</link>
		<comments>http://blog.jobbole.com/107025/#comments</comments>
		<pubDate>Tue, 25 Oct 2016 01:14:24 +0000</pubDate>
		<dc:creator><![CDATA[(●'◡'●)]]></dc:creator>
				<category><![CDATA[IT技术]]></category>
		<category><![CDATA[后端]]></category>
		<category><![CDATA[成长]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=107025</guid>
		<description><![CDATA[<p>有不少初学者问到，我想学习后端，但是又不知道该怎么学，所以我决定把这几年的经验和经历整理成一篇文章，分析后端的路该怎么走，先说明下面仅仅是个人心得，也许与外面的理论有所不同。</p><p><a href="http://blog.jobbole.com/107025/">后端成长之路：从菜鸟到架构</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<div>
<p>有不少初学者问到，我想学习后端，但是又不知道该怎么学，所以我决定把这几年的经验和经历整理成一篇文章，分析后端的路该怎么走，先说明下面仅仅是个人心得，也许与外面的理论有所不同。（文章最后面会附上学习路线地图和一些自己看过的书籍）</p>
<div><img src="http://jbcdn2.b0.upaiyun.com/2016/10/57246d398ba3d4414ca76b9db411f8bf.png" /></p>
<div style="text-align: center"><em>后端任务其实是实现接收输入响应输出</em></div>
</div>
<h3>后端初接触</h3>
<p>后端首先需要学习的是html，css和js，也许你会问做网页不是前端做的事情吗？答案是对于真实开发环境后端很多时候还兼顾了前端这个角色，对于架构来说优化不仅仅要考虑后端还需要考虑前端。</p>
<p>要学到什么样的程度才可以学下一样技能呢？我的建议是能够搭建起一个简单的页面，最重要的是学会dom操作和ajax。</p>
<h3>语言选择</h3>
<p>我相信过来人或者正在入门的人都碰到过这个世纪难题，如果你是初学者我建议您使用java。这里并不是说我喜欢java才推荐你们用java入门，而是java的思想对我们以后开发有很不错的启发。当你学会一种语言的基本语法就可以到下一步了（仅仅是语法，任意语言）。</p>
<h3>hello world！</h3>
<p>没错，这个时候，你得让浏览器可以看到hello world！ 为了实现这个小目标，我们就需要根据语言配置不同的运行环境。由于入门，我建议可以使用一些集成的一键配置环境软件，例如php可以用phpstudy，java看看教程，下载一个tomcat然后跟eclipse集成就好，而python或则ruby则使用一个轻量级的web框架，copy一下官网提供的hello world！例子即可。</p>
<h3>高级一些的hello world</h3>
<p>这个阶段，你需要实现的是通过浏览器输入不同的网址，你可以输出不同的内容。然后要弄明白什么是get参数，什么是post参数。然后要实现根据不同get参数或者post参数输出不同内容。因为后端研发从根本上来说就是处理这些不同输入，输出特定的内容回去而已，所以这一步，最关键。</p>
<h3>数据库</h3>
<p>为什么我们要用数据库呢？以一个新闻网站为例，它要保存新闻数据，还得保存用户信息，也要保存评论信息。也许你会问用文件保存就好了，为何还要学习数据库这么庞大的东西呢？首先，我们来看一下什么是数据库，我们可以把数据库每一个table看成excel的sheet，每一个db就是一个excel文件。而sql语句就是一条条指令，可以帮我们操作里面的数据，可以节省我们大量的操作。开始学习数据库的时候，我建议学习mysql。</p>
<div><img src="http://jbcdn2.b0.upaiyun.com/2016/10/c641098c6e85e5249bdb1bb3ebe2268f.png" /></p>
<div style="text-align: center"><em>数据库</em></div>
</div>
<h3>模板引擎</h3>
<p>一项技术的出现，往往在于解决了一些开发难题。在没有模板引擎之前，我们得使用字符串拼接方式，弄成html字符串，但是这种方式很容易出错的。而模板引擎无需字符串拼接，并且可以处理字符串转义问题，并且模板集成，模板引用等功能，可以使代码可以重用，大大提高了开发效率，工程也更容易维护。</p>
<div><img src="http://jbcdn2.b0.upaiyun.com/2016/10/e67a56ef677d62d73f6d16295d63cd35.png" /></p>
<div style="text-align: center"><em>模板引擎</em></div>
</div>
<h3>MVC框架</h3>
<p>首先，我们得明白为什么要用框架？假如是第一次接触，我相信第一感受是用了框架加重自己的开发负担。然后框架存在必然有自己的合理性，我们来看看框架有什么优点。</p>
<p>1. 框架提供了大量的方法封装，我们可以直接调用来解决业务问题，这可以大大提高开发效率。</p>
<p>2. 框架能够帮我们分层编写代码，能够在后期更好的维护我们的项目。</p>
<p>3. 做一些安全防护，处理一些常见的攻击。</p>
<p>所以对于各种语言，大家可以选择一个对应的框架来学习。那么我们应该如何挑选一个框架呢？</p>
<p>1. 多人用的（最起码使用过程中遇到问题，都能找到人问）</p>
<p>2. 文档详细的（文档不详细，怎么去学习呢？）</p>
<p>3. 简单的（未来的趋势估计都是往轻量级框架走的）</p>
<div><img src="http://jbcdn2.b0.upaiyun.com/2016/10/c630fc5e98adaea0df3ba4be15ce20c0.png" /></p>
<div style="text-align: center"><em>MVC框架有利于维护</em></div>
</div>
<h3>Linux与应用部署</h3>
<p>开发用window没什么问题，但是我们做的应用绝大部分是要放在linux系统来对外提供服务器，所以不懂linux的操作是不行的，并且服务器为了尽可能节省资源，都是不使用界面的，所以我们要学好大量的linux命令。</p>
<p>服务器环境我们一般就不会用外面的通用的一键安装环境，往往需要优化的。所以基本的软件安装和配置需要学会，特别是近年来很火的docker，越来越多都是基于docker来部署的啦。</p>
<h3>缓存</h3>
<p>缓存可是处理高并发的万能药，每当你写的功能慢的时候，基本上你都可以通过缓存来大大提高网站性能。实现缓存的方法很简单，但是一当在并发下和海量数据面前一切都不容易，还得上分布式集群这些。</p>
<h3>http协议</h3>
<p>如果上面的你都接触了，恭喜您普通开发估计是没问题了，如果你说很多需求还是做不出，没关系，其实你只是缺乏开发经验而已，只要多写多请教，你就会发现，其实后端研发也没什么难度。这个时候，如果我们想往高级研发工程师方向走，一些底层的高级的东西我们得学会。</p>
<div><img src="http://jbcdn2.b0.upaiyun.com/2016/10/1afa53496ed74231288a89ecaac85318.png" /></p>
<div style="text-align: center"><em>http协议</em></div>
</div>
<p>浏览器与服务器通过http协议交互，其实就是相互之间传递一串特定格式的字符串。get参数，post参数，url，和cookie等信息其实都包含在这字符串里面。我们平时虽然没有怎么碰到这些底层的东西，其实是框架和tomcat这种软件帮我们处理了。</p>
<p>就像平时一个重定向，其实就在header里面有一句Location: XXX。而我们平时声明返回的是html还是json其实是headers有一句Content-Type:XXX，一切神奇的功能其实仅仅是一段特定的字符串而已，所以http协议怎么可以不研究呢。</p>
<h3>nosql</h3>
<p>非关系型数据库有很多，例如memcached，redis，mongodb，coundb等。这些东西都有自己的适用场景，合理利用可以加快开发效率，对提高应用性能有很大的帮助的。</p>
<h3>消息中间件</h3>
<p>这种技术的出现是为了解耦，当我们业务过于庞大的时候，就会相应的拆分成几个小系统，系统之间的通讯往往是通过http协议调用和基于消息中间件。通过http协议有一个弊端，就是某个系统一旦修改了地址，那么就必须修改调用该服务的系统。如果通过消息中间件调用，那么应用如何迁移，也不会影响到别的系统。</p>
<div><img src="http://jbcdn2.b0.upaiyun.com/2016/10/c77dd3a954e0e2d3aa43efe200e4ea00.png" /></p>
<div style="text-align: center"><em>消息中间件</em></div>
</div>
<h3>一点点话</h3>
<p>你跟所谓的大牛差距在哪里呢？我的看法是差距仅仅在于项目经验。也许你会说后端怎么需要学习这么多东西，并且年年都有新的技术出现怎么学呢？其实对于一种新技术，我们主要是要弄明白我们为什么要用这种技术，因为存在即合理，新技术的出现必然有自己的原因，所以新技术不一定要追求，但是底层建议要理解。然后什么海量数据和高并发下系统优化，一个原则，找到性能瓶颈并解决它而已。</p>
<h3>附录</h3>
<p><i><b>路线图</b></i></p>
<div><img src="http://jbcdn2.b0.upaiyun.com/2016/10/d353fc11e1878db80efc5f339420fe6f.png" /></p>
<div style="text-align: center"><em>一个简单的学习路线图</em></div>
</div>
<p><b><i>书单（下面仅仅是一些个人以前看过的书籍，并不是推荐要看，个人建议看看哪种讲解核心的书籍，怎么制作比怎么用更总要）</i></b></p>
<blockquote><p>LINUX操作系统(第2版)</p>
<p>LINUX指令范例速查手册</p>
<p>JSP &amp; SERVLET学习笔记</p>
<p>STRUTS 2．X权威指南(第3版)</p>
<p>HTML 5从入门到精通</p>
<p>JAVA入门经典(第6版)</p>
<p>看透Spring MVC：源代码分析与实践</p>
<p>大型分布式网站架构设计与实践</p>
<p>Docker 容器与容器云</p>
<p>Python Cookbook（第3版）中文版</p>
<p>Go语言程序设计</p>
<p>MongoDB大数据处理权威指南（第2版）</p>
<p>NoSQL数据库技术实战</p>
<p>构建高可用Linux服务器（第3版）</p>
<p>大型网站技术架构 核心原理与案例分析</p>
<p>Linux运维之道</p>
<p>高性能MySQL（第3版）</p>
<p>Java核心技术 卷I</p>
<p>Java核心技术 卷II</p></blockquote>
</div>
<p><a href="http://blog.jobbole.com/107025/">后端成长之路：从菜鸟到架构</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/107025/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>一些实用的 Laravel 小技巧</title>
		<link>http://blog.jobbole.com/107018/</link>
		<comments>http://blog.jobbole.com/107018/#respond</comments>
		<pubDate>Mon, 24 Oct 2016 05:47:26 +0000</pubDate>
		<dc:creator><![CDATA[scsecrystal]]></dc:creator>
				<category><![CDATA[PHP]]></category>
		<category><![CDATA[开发]]></category>
		<category><![CDATA[Laravel]]></category>
		<category><![CDATA[php]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=107018</guid>
		<description><![CDATA[<p>Laravel 中一些常用的小技巧，额，说不定你就用上了。。。</p><p><a href="http://blog.jobbole.com/107018/">一些实用的 Laravel 小技巧</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p>Laravel 中一些常用的小技巧，额，说不定你就用上了。。。<img src="http://jbcdn2.b0.upaiyun.com/2016/10/6dbf36b1c3d4f04508cd2ef5364b3f1a.png" /></p>
<h2>1.侧栏</h2>
<p>网站一般都有侧栏，用来显示分类，标签，热门文章，热门评论啥的，但是这些侧栏都是相对独立的模块，如果在每一个引入侧栏的视图中都单独导入与视图有关的数据的话，未免太冗余了。。。所以最佳的做法是：新建一个<code>widgets</code>视图文件夹，再利用Laravel 的<code>ViewComposers</code>单独为侧栏绑定数据，这样侧栏就可以随便引入而不用关心数据是否绑定啦~~~</p>
<p>举个栗子？拿最常用的分类侧栏来说，在<code>resources/views/widgets</code>下新建你的分类侧栏视图文件<code>categories.blade.php</code>：</p>
<div class="widget widget-default">
<div class="widget-header">
<pre class="crayon-plain-tag">&lt;div class="widget widget-default"&gt;
    &lt;div class="widget-header"&gt;&lt;h6&gt;&lt;i class="fa fa-folder fa-fw"&gt;&lt;/i&gt;分类&lt;/h6&gt;&lt;/div&gt;
    &lt;ul class="widget-body list-group"&gt;
        @forelse($categories as $category)
            @if(str_contains(urldecode(request()-&gt;getPathInfo()),'category/'.$category-&gt;name))
                &lt;li href="{{ route('category.show',$category-&gt;name) }}"
                    class="list-group-item active"&gt;
                    {{ $category-&gt;name }}
                    &lt;span class="badge"&gt;{{ $category-&gt;posts_count }}&lt;/span&gt;
                &lt;/li&gt;
            <a href='http://www.jobbole.com/members/wx2715401697'>@else</a>
                &lt;a href="{{ route('category.show',$category-&gt;name) }}"
                   class="list-group-item"&gt;
                    {{ $category-&gt;name }}
                    &lt;span class="badge"&gt;{{ $category-&gt;posts_count }}&lt;/span&gt;
                &lt;/a&gt;
            <a href='http://www.jobbole.com/members/endif1983'>@endif</a>
        <a href='http://www.jobbole.com/members/mxbeijing2007'>@empty</a>
            &lt;p class="meta-item center-block"&gt;No categories.&lt;/p&gt;
        @endforelse
    &lt;/ul&gt;
&lt;/div&gt;</pre>
</div>
</div>
<p>新建<code>app/Http/ViewComposers</code>文件夹，然后创建<code>CategoriesComposer.php</code>：</p><pre class="crayon-plain-tag">&lt;?php
namespace App\Http\ViewComposers;
use App\Http\Repositories\CategoryRepository;
use Illuminate\View\View;
class CategoriesComposer
{
    public function __construct(CategoryRepository $categoryRepository)
    {
        $this-&gt;categoryRepository = $categoryRepository;
    }

    public function compose(View $view)
    {
        $categories = $this-&gt;categoryRepository-&gt;getAll()-&gt;reject(function ($category) {
            return $category-&gt;posts_count == 0;
        });
        $view-&gt;with('categories', $categories);
    }
}</pre><p>再在<code>app/Providers</code>文件夹下新建<code>ComposerServiceProvider.php</code>文件：</p><pre class="crayon-plain-tag">&lt;?php
namespace App\Providers;
use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Facades\View;
class ComposerServiceProvider extends ServiceProvider
{

    public function boot()
    {
        View::composer('widget.categories', 'App\Http\ViewComposers\CategoriesComposer');
    }

    public function register(){}
}</pre><p>最后别忘了在<code>config/app.php</code>中的<code>providers</code>数组中添加<code>AppProvidersComposerServiceProvider::class</code>啊。好了，现在你可以随时随地<code>@include('widget.categories')</code>了。对了，要善于在<code>ViewComposer</code>中利用<code>Collection</code>的<a href="https://laravel.com/docs/5.3/eloquent-collections#available-methods">强大方法</a>进行数据处理幺~~</p>
<h2>2.善用路由别名</h2>
<p>Laravel 最让人喜欢的地方之一是可以给路由起一个别名，比如：</p><pre class="crayon-plain-tag">Route::get('user/profile', 'UserController@showProfile')-&gt;name('user.profile');
// 等价于：
Route::get('user/profile', ['uses' =&gt; 'UserController@showProfile' , 'as' =&gt; 'user.profile']);;</pre><p>然后，就可以在试图中就可以使用<code>route()</code>方法引用了：</p><pre class="crayon-plain-tag">// 例如：
&lt;a href="{{ route('user.profile') }}"&gt;lufficc&lt;/a&gt;</pre><p>因为一个普通的项目路由至少也得有几十个，如果使用<code>url()</code>方法的话，你不但要记住具体的路由，更麻烦的是如果你将来想要改变某个路由（比如把<code>'user/profile'</code>改为<code>'u/profile'</code>，或者加个前缀啥的），必须改变所有相关的视图文件，这。。。这。。。不敢相信，而使用命名路由的话，只要命名不变，毫不受影响。</p>
<p>所以视图文件中尽量避免使用<code>url()</code>方法，为每一个路由命名，一个默认的命名规则为：<code>资源名称.或者</code>，如<code>post.show</code>，<code>image.upload</code>。</p>
<h2>3.全局动态设置</h2>
<p>仅仅是<code>.env</code>的配置还无法满足我们的需求，有时我们需要可以在后台动态的进行一些设置，比如网站的标题，网站的背景图片或者是否允许评论等等。那么实现这个的最佳实践是什么？</p>
<p>熟悉wordpress的同学知道，wordpress可以进行很多自定义，因为wordpress有一张键值对数据库表，它就是靠这个实现个性化的。因此我们也可以参考这种思路，增加一个键值对表，以<a href="https://github.com/lufficc/Xblog">Xblog</a>为例子，新建一个<code>maps</code>表：</p><pre class="crayon-plain-tag">Schema::create('maps', function (Blueprint $table) {
       $table-&gt;increments('id');
       $table-&gt;string('key')-&gt;unique();
       $table-&gt;string('tag')-&gt;index();
       $table-&gt;text('value')-&gt;nullable(true);
});</pre><p><code>maps</code>表的作用就是实现键值对<code>key-value</code>存储，<code>tag</code>的是为了可以有一个分类。然后后台进行存储的话，不要写死，这样就可以随时在变单中添加设置而无需更改代码：</p><pre class="crayon-plain-tag">$inputs = $request-&gt;except('_token');
foreach ($inputs as $key =&gt; $value) {
            $map = Map::firstOrNew([
                'key' =&gt; $key,
            ]);
            $map-&gt;tag = 'settings';
            $map-&gt;value = $value;
            $map-&gt;save();
}</pre><p>注意<code>firstOrNew</code>的用法：如果不存在这个选项我们就新增一个并保存，否则就更新它。然后我们就可以在视图中随便增加任意多个表单了（或者也可以用js动态生成表单）。有了数据，怎么在视图中利用呢？利用<code>ViewComposer</code>，新建一个<code>SettingsComposer.php</code>，然后将查询的数据以数组的形式传递给视图：</p><pre class="crayon-plain-tag">//在SettingsComposer.php的compose方法中绑定数据
public function compose(View $view)
{
    $settings = Map::where('tag', 'settings')-&gt;get();
    $arr = [];
    foreach ($settings as $setting) {
      $arr[$setting-&gt;key] = $setting-&gt;value;
    }
   $view-&gt;with($arr);
}</pre><p>然后就可以在视图中随便引用了，如你表单新增加了一个<code>description</code></p><pre class="crayon-plain-tag">&lt;input type="text" name="description" value="{{ $description or ''}}"&gt;</pre><p>然后就可以在任何视图引用了:<code>{{ $description or ''}}</code>。另外还可以绑定一个单例<code>Facades</code>到容器，这样就可以在代码中随时获取配置信息啦~~~<br />
比如：</p><pre class="crayon-plain-tag">//1.注册
public function register()
{
    $this-&gt;app-&gt;singleton('XblogConfig', function ($app) {
       return new MapRepository();
   });
}
//2.注册Facade
class XblogConfig extends Facade
{
    public static function getFacadeAccessor()
    {
        return 'XblogConfig';
    }
}
//3.添加到aliases数组

'aliases' =&gt; [

        *****************  省略  *************************
        'XblogConfig' =&gt; App\Facades\XblogConfig::class,
    ],

//4.愉快的使用，可爽
$page_size = XblogConfig::getValue('page_size', 7);</pre><p></p>
<h2>4.数据库查询</h2>
<p>怎么统计一篇文章有多少评论？最快的方法是：</p><pre class="crayon-plain-tag">$post = Post::where('id',1)-&gt;withCount('comments')-&gt;first();</pre><p>这样<code>$post</code>变量就有一个属性<code>comments_count</code>了：</p><pre class="crayon-plain-tag">$post-&gt;comments_count;</pre><p>如果想获取点赞数大于的100的评论个数怎么办？这样：</p><pre class="crayon-plain-tag">$post = Post::where('id',1)-&gt;withCount('comments',function($query){
       $query-&gt;where('like', '&gt;', 100);
   })-&gt;first();</pre><p>简单吧~~</p>
<h2>5.多态关联</h2>
<p>文章可以有评论，页面可以有评论，评论也可以有评论，但是总不能建三张评论表吧？如果自己写条件判断也太麻烦了吧。。。Laravel的多态关联上场了！！</p><pre class="crayon-plain-tag">//1.第一步在Comment模型中说明我是可以多态的
public function commentable()
{
    return $this-&gt;morphTo();
}

//2.在想要评论的模型中增加comments方法，
public function comments()
{
    return $this-&gt;morphMany(Comment::class, 'commentable');
}

//3.使用，就像普通的一对多关系一样：
$model-&gt;comments;</pre><p>原理很简单，<code>comments</code>表中增加两个列就行：</p><pre class="crayon-plain-tag">Schema::create('comments', function (Blueprint $table) {
     ***************省略*******************
     $table-&gt;morphs('commentable');
     //等价于
     $table-&gt;integer('commentable_id')-&gt;index();
     $table-&gt;string('commentable_type')-&gt;index();
    ****************省略******************
});</pre><p>然后 laravel 会自动维持这些关系。注意，保存的评论的时候是有小技巧的，你的表单中至少要传两个参数：<code>commentable_id</code>和<code>commentable_type</code>：</p><pre class="crayon-plain-tag">$comment = new Comment();

$commentable_id = $request-&gt;get('commentable_id');
//commentable_type取值例如：AppPost，AppPage等等
$commentable = app($request-&gt;get('commentable_type'))-&gt;where('id', $commentable_id)-&gt;firstOrFail();

****************省略******************

$commentable-&gt;comments()-&gt;save($comment);</pre><p>保存评论的时候并不知道是谁的评论，而是使用容器根据<code>commentable_type</code>生成一个模型实例，这样也就和具体的模型解耦了，你可以让任何东西可以评论，而不需要修改代码。</p>
<h2>6.缓存优化相关</h2>
<p>如果你想要在<code>.env</code>文件中添加自己的配置，记住一定要在<code>config</code>文件夹下某个配置文件的数组中添加对应的。记住，除了<code>config</code>文件夹下的配置文件，永远不要在其它地方使用<code>env</code>函数，因为部署到线上时，配置文件缓存（<code>php artisan config:cache</code>）后，<code>env</code>函数无法获得正确的值。</p>
<p>另外注意的是，路由文件中尽量不使用闭包函数，统一使用控制器，因为缓存路由的时候<code>php artisan route:cache</code>，无法缓存闭包函数。</p>
<h2>7.Redis</h2>
<p>如果你缓存使用Redis，<code>session</code>也使用了Redis，队列已使用了Redis，这样没问题，速度很快，但是！！当你运行<code>php artisan cache:clear</code>清除缓存时，会把你的登录信息清除，也会把队列清除。。。这就不优雅了。解决办法很简单，为它们分配不同的连接即可。<br />
首先在<code>configdatabase.php</code>中增加连接，注意<code>database</code>序号：</p><pre class="crayon-plain-tag">'redis' =&gt; [

        'cluster' =&gt; false,

        'default' =&gt; [
            'host' =&gt; env('REDIS_HOST', 'localhost'),
            'password' =&gt; env('REDIS_PASSWORD', null),
            'port' =&gt; env('REDIS_PORT', 6379),
            'database' =&gt; 0,
        ],
        'session' =&gt; [
            'host' =&gt; env('REDIS_HOST', 'localhost'),
            'password' =&gt; env('REDIS_PASSWORD', null),
            'port' =&gt; env('REDIS_PORT', 6379),
            'database' =&gt; 1,
        ],
        'queue' =&gt; [
            'host' =&gt; env('REDIS_HOST', 'localhost'),
            'password' =&gt; env('REDIS_PASSWORD', null),
            'port' =&gt; env('REDIS_PORT', 6379),
            'database' =&gt; 2,
        ],

    ],</pre><p>然后分别为<code>session</code>和<code>queue</code>更换连接：</p><pre class="crayon-plain-tag">//queue.php中的connections数组中：
'redis' =&gt; [
            'driver' =&gt; 'redis',
            'connection' =&gt; 'queue',
            'queue' =&gt; 'default',
            'retry_after' =&gt; 90,
        ],

//session.php中的connection选项：
'connection' =&gt; 'session',</pre><p>这样他们就互不相干了~~</p>
<p><strong><em>以上经验来自<a href="https://github.com/lufficc/Xblog">Xblog</a>，示例均可以在<a href="https://github.com/lufficc/Xblog">Xblog</a>找到</em></strong></p>
<p><a href="http://blog.jobbole.com/107018/">一些实用的 Laravel 小技巧</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/107018/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>深入Go UDP编程</title>
		<link>http://blog.jobbole.com/107004/</link>
		<comments>http://blog.jobbole.com/107004/#respond</comments>
		<pubDate>Mon, 24 Oct 2016 04:08:41 +0000</pubDate>
		<dc:creator><![CDATA[ABOER]]></dc:creator>
				<category><![CDATA[IT技术]]></category>
		<category><![CDATA[UDP]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=107004</guid>
		<description><![CDATA[<p>用户数据报协议（User Datagram Protocol，缩写为UDP），又称用户数据报文协议，是一个简单的面向数据报的传输层协议，正式规范为RFC 768。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份，所以UDP有时候也被认为是不可靠的数据报协议。</p><p><a href="http://blog.jobbole.com/107004/">深入Go UDP编程</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p style="text-align: justify">用户数据报协议（User Datagram Protocol，缩写为UDP），又称用户数据报文协议，是一个简单的面向数据报(package-oriented)的传输层协议，正式规范为RFC 768。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验。</p>
<p style="text-align: justify">由于缺乏可靠性且属于非连接导向协议，UDP应用一般必须允许一定量的丢包、出错和复制粘贴。但有些应用，比如TFTP，如果需要则必须在应用层增加根本的可靠机制。但是绝大多数UDP应用都不需要可靠机制，甚至可能因为引入可靠机制而降低性能。流媒体（流技术）、即时多媒体游戏和IP电话（VoIP）一定就是典型的UDP应用。如果某个应用需要很高的可靠性，那么可以用传输控制协议（TCP协议）来代替UDP。</p>
<p style="text-align: justify">由于缺乏拥塞控制（congestion control），需要基于网络的机制来减少因失控和高速UDP流量负荷而导致的拥塞崩溃效应。换句话说，因为UDP发送者不能够检测拥塞，所以像使用包队列和丢弃技术的路由器这样的网络基本设备往往就成为降低UDP过大通信量的有效工具。数据报拥塞控制协议（DCCP）设计成通过在诸如流媒体类型的高速率UDP流中，增加主机拥塞控制，来减小这个潜在的问题。<br />
典型网络上的众多使用UDP协议的关键应用一定程度上是相似的。这些应用包括域名系统（DNS）、简单网络管理协议（SNMP）、动态主机配置协议（DHCP）、路由信息协议（RIP）和某些影音流服务等等。</p>
<p style="text-align: justify">UDP报头</p>
<p style="text-align: justify"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/8c2cd6854c4b8e0c3ff95c4e5dc46a0b.png"><img class="alignnone size-full wp-image-107006" src="http://jbcdn2.b0.upaiyun.com/2016/10/8c2cd6854c4b8e0c3ff95c4e5dc46a0b.png" alt="table1" /></a></p>
<p style="text-align: justify"><strong>IPv4伪头部<a href="http://jbcdn2.b0.upaiyun.com/2016/10/97bb0b7d7da40643dadd6dccc44516c4.png"><img class="alignnone size-full wp-image-107007" src="http://jbcdn2.b0.upaiyun.com/2016/10/97bb0b7d7da40643dadd6dccc44516c4.png" alt="table2" /></a></strong></p>
<p style="text-align: justify"><strong>IPv6伪头部<a href="http://jbcdn2.b0.upaiyun.com/2016/10/39566e408035d3601a0f0a98ea0a5203.png"><img class="alignnone size-full wp-image-107008" src="http://jbcdn2.b0.upaiyun.com/2016/10/39566e408035d3601a0f0a98ea0a5203.png" alt="table3" /></a></strong></p>
<p style="text-align: justify">以上大段的背景介绍引自维基百科。</p>
<p style="text-align: justify">而TCP是面向连接(connection-oriented)的协议，可以提供可靠的数据传输。</p>
<p style="text-align: justify">本文讲介绍Go语言的UDP库及其使用方法，以及了解使用过程中的细节和陷阱。</p>
<h2 id="一个简单的例子" style="text-align: justify">一个简单的例子</h2>
<p style="text-align: justify">首先看一个简单的UDP的例子，这个例子演示了Go UDP通过<code>Dial</code>方式发送数据报的例子。</p>
<figure style="text-align: justify">
<pre class="crayon-plain-tag">package main
import (
	"fmt"
	"net"
)
func main() {
	listener, err := net.ListenUDP("udp", &amp;net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 9981})
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Local: &lt;%s&gt; \n", listener.LocalAddr().String())
	data := make([]byte, 1024)
	for {
		n, remoteAddr, err := listener.ReadFromUDP(data)
		if err != nil {
			fmt.Printf("error during read: %s", err)
		}
		fmt.Printf("&lt;%s&gt; %s\n", remoteAddr, data[:n])
		_, err = listener.WriteToUDP([]byte("world"), remoteAddr)
		if err != nil {
			fmt.Printf(err.Error())
		}
	}
}</pre><br />
<pre class="crayon-plain-tag">package main
import (
	"fmt"
	"net"
)
func main() {
	sip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	conn.Write([]byte("hello"))
	fmt.Printf("&lt;%s&gt;\n", conn.RemoteAddr())
}</pre></p>
<p style="text-align: justify">可以看到, Go UDP的处理类似TCP的处理，虽然不像TCP面向连接的方式<code>ListenTCP</code>和<code>Accept</code>的方式建立连接,但是它通过<code>ListenUDP</code>和<code>ReadFromUDP</code>可以接收各个客户端发送的数据报，并通过<code>WriteToUDP</code>写数据给特定的客户端。</p>
<p style="text-align: justify">我们稍微修改一下client1.go,让它保持UDP Socket文件一直打开：</p>
<p></p><pre class="crayon-plain-tag">func main() {
	ip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	b := make([]byte, 1)
	os.Stdin.Read(b)
	conn.Write([]byte("hello"))
	fmt.Printf("&lt;%s&gt;\n", conn.RemoteAddr())
}</pre><p></p>
<p style="text-align: justify">使用 <code>netstat</code>可以看到这个网络文件描述符(因为我在同一台机器上运行服务器，所以你会看到两条记录，一个是服务器打开的，一个是客户端打开的)。</p>
<p></p><pre class="crayon-plain-tag">udp4       0      0  localhost.54676        localhost.9981
udp4       0      0  localhost.9981         *.*</pre><p></figure>
<p style="text-align: justify">或者使用<code>lsof</code>命令查看：</p>
<p></p><pre class="crayon-plain-tag">server1   59312 smallnest    3u  IPv4 0xad793a9a54467f61      0t0  UDP localhost:9981
client1   59323 smallnest    3u  IPv4 0xad793a9a544681c1      0t0  UDP localhost:54676-&gt;localhost:9981</pre><p></p>
<h2 id="更复杂的例子" style="text-align: justify">更复杂的例子</h2>
<p style="text-align: justify">我们还可以将上面的例子演化一下，实现双向的读写。</p>
<p style="text-align: justify">服务器端代码不用修改，因为它已经实现了读写，读是通过<code>listener.ReadFromUDP</code>,写通过<code>listener.WriteToUDP</code>。</p>
<p style="text-align: justify">客户端修改为读写：</p>
<p></p><pre class="crayon-plain-tag">package main
import (
	"fmt"
	"net"
)
func main() {
	ip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	conn.Write([]byte("hello"))
	data := make([]byte, 1024)
	n, err := conn.Read(data)
	fmt.Printf("read %s from &lt;%s&gt;\n", data[:n], conn.RemoteAddr())
}</pre><p></p>
<p style="text-align: justify">这里client的写是<code>Write</code>,读是<code>Read</code>。</p>
<h2 id="等价的客户端和服务器" style="text-align: justify">等价的客户端和服务器</h2>
<p style="text-align: justify">下面这个是两个服务器通信的例子，互为客户端和服务器，在发送数据报的时候，我们可以将发送的一方称之为源地址，发送的目的地一方称之为目标地址。</p>
<p></p><pre class="crayon-plain-tag">package main
import (
	"fmt"
	"net"
	"os"
	"time"
)
func read(conn *net.UDPConn) {
	for {
		data := make([]byte, 1024)
		n, remoteAddr, err := conn.ReadFromUDP(data)
		if err != nil {
			fmt.Printf("error during read: %s", err)
		}
		fmt.Printf("receive %s from &lt;%s&gt;\n", data[:n], remoteAddr)
	}
}
func main() {
	addr1 := &amp;net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 9981}
	addr2 := &amp;net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 9982}
	go func() {
		listener1, err := net.ListenUDP("udp", addr1)
		if err != nil {
			fmt.Println(err)
			return
		}
		go read(listener1)
		time.Sleep(5 * time.Second)
		listener1.WriteToUDP([]byte("ping to #2: "+addr2.String()), addr2)
	}()
	go func() {
		listener1, err := net.ListenUDP("udp", addr2)
		if err != nil {
			fmt.Println(err)
			return
		}
		go read(listener1)
		time.Sleep(5 * time.Second)
		listener1.WriteToUDP([]byte("ping to #1: "+addr1.String()), addr1)
	}()
	b := make([]byte, 1)
	os.Stdin.Read(b)
}</pre><p></p>
<h2 id="Read和Write方法集的比较" style="text-align: justify">Read和Write方法集的比较</h2>
<p style="text-align: justify">前面的例子中客户端有时使用<code>DialUDP</code>建立数据报的源对象和目标对象(地址和端口), 它会创建UDP Socket文件描述符,然后调用内部的<code>connect</code>为这个文件描述符设置源地址和目标地址，这时Go将它称之为<code>connected</code>,尽管我们知道UDP是无连接的协议，Go这种叫法我想根源来自Unix/Linux的UDP的实现。这个方法返回<code>*UDPConn</code>。</p>
<p style="text-align: justify">有的时候却可以通过<code>ListenUDP</code>返回的<code>*UDPConn</code>直接往某个目标地址发送数据报，而不是通过<code>DialUDP</code>方式发送，原因在于两者返回的<code>*UDPConn</code>是不同的。前者是<code>connected</code>，后者是<code>unconnected</code>。</p>
<p style="text-align: justify">你必须清楚知道你的UDP是连接的(connected)还是未连接(unconnected)的，这样你才能正确的选择的读写方法。</p>
<p style="text-align: justify">如果<code>*UDPConn</code>是<code>connected</code>,读写方法是<code>Read</code>和<code>Write</code>。<br />
如果<code>*UDPConn</code>是<code>unconnected</code>,读写方法是<code>ReadFromUDP</code>和<code>WriteToUDP</code>（以及<code>ReadFrom</code>和<code>WriteTo</code>)。</p>
<p style="text-align: justify">事实上Go的这种设计和Unix/Linux设计一致，下面是Linux关于UDP的文档：</p>
<blockquote><p>When a UDP socket is created, its local and remote addresses are unspecified. Datagrams can be sent immediately using <code>sendto</code> or <code>sendmsg</code> with a valid destination address as an argument. When <code>connect</code> is called on the socket, the default destination address is set and datagrams can now be sent using <code>send</code> or <code>write</code> without specifying a destination address. It is still possible to send to other destinations by passing an address to <code>sendto</code> or <code>sendmsg</code>. In order to receive packets, the socket can be bound to a local address first by using <code>bind</code>. Otherwise, the socket layer will automatically assign a free local port out of the range defined by <code>/proc/sys/net/ipv4/ip_local_port_range</code> and bind the socket to INADDR_ANY.</p></blockquote>
<p style="text-align: justify"><code>ReadFrom</code>和<code>WriteTo</code>是为了实现<code>PacketConn</code>接口而实现的方法，它们的实现基本上和<code>ReadFromUDP</code>和<code>WriteToUDP</code>一样，只不过地址换成了更通用的<code>Addr</code>,而不是具体化的<code>UDPAddr</code>。</p>
<p style="text-align: justify">还有几种情况需要弄清楚:<br />
<strong>1、</strong><br />
因为<code>unconnected</code>的<code>*UDPConn</code>还没有目标地址，所以需要把目标地址当作参数传入到<code>WriteToUDP</code>的方法中，但是<code>unconnected</code>的<code>*UDPConn</code>可以调用<code>Read</code>方法吗？</p>
<p style="text-align: justify">答案是<strong>可以</strong>,但是在这种情况下，客户端的地址信息就被忽略了。</p>
<p></p><pre class="crayon-plain-tag">func main() {
	listener, err := net.ListenUDP("udp", &amp;net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 9981})
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Local: &lt;%s&gt; \n", listener.LocalAddr().String())
	data := make([]byte, 1024)
	for {
		n, err := listener.Read(data)
		if err != nil {
			fmt.Printf("error during read: %s", err)
		}
		fmt.Printf("&lt;%s&gt;\n", data[:n])
	}
}</pre><p></p>
<p style="text-align: justify"><strong>2、</strong><br />
<code>unconnected</code>的<code>*UDPConn</code>可以调用<code>Write</code>方法吗？<br />
答案是<strong>不可以</strong>， 因为不知道目标地址。</p>
<p></p><pre class="crayon-plain-tag">func main() {
	listener, err := net.ListenUDP("udp", &amp;net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: 9981})
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Local: &lt;%s&gt; \n", listener.LocalAddr().String())
	_, err = listener.Write([]byte("hello"))
	if err != nil {
		fmt.Printf(err.Error())
	}
}</pre><p></p>
<p style="text-align: justify">出错：</p>
<p></p><pre class="crayon-plain-tag">write udp 127.0.0.1:9981: write: destination address requiredsmallnestMBP:udp smallnest</pre><p></p>
<p style="text-align: justify"><strong>3、</strong><br />
<code>connected</code>的<code>*UDPConn</code>可以调用<code>WriteToUDP</code>方法吗？<br />
答案是<strong>不可以</strong>， 因为目标地址已经设置。<br />
即使是相同的目标地址也<strong>不可以</strong>。</p>
<p></p><pre class="crayon-plain-tag">func main() {
	ip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	_, err = conn.WriteToUDP([]byte("hello"), dstAddr)
	if err != nil {
		fmt.Println(err)
	}
}</pre><p></p>
<p style="text-align: justify">报错:</p>
<p></p><pre class="crayon-plain-tag">write udp 127.0.0.1:50141-&gt;127.0.0.1:9981: use of WriteTo with pre-connected connection</pre><p></p>
<p style="text-align: justify"><strong>4、</strong><br />
<code>connected</code>的<code>*UDPConn</code>如果调用<code>Closed</code>以后可以调用<code>WriteToUDP</code>方法吗？<br />
答案是<strong>不可以</strong>。</p>
<p></p><pre class="crayon-plain-tag">func main() {
	ip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	err = conn.Close()
	if err != nil {
		fmt.Println(err)
	}
	_, err = conn.WriteToUDP([]byte("hello"), dstAddr)
	if err != nil {
		fmt.Println(err)
	}
}</pre><p></p>
<p style="text-align: justify">同样的报错：</p>
<p></p><pre class="crayon-plain-tag">write udp 127.0.0.1:59074-&gt;127.0.0.1:9981: use of WriteTo with pre-connected connection</pre><p></p>
<p style="text-align: justify"><strong>5、</strong><br />
<code>connected</code>的<code>*UDPConn</code>可以调用<code>ReadFromUDP</code>方法吗？<br />
答案是<strong>可以</strong>,但是它的功能基本和<code>Read</code>一样，只能和它<code>connected</code>的对端通信。</p>
<p style="text-align: justify">看下面的client的例子：</p>
<p></p><pre class="crayon-plain-tag">func main() {
	ip := net.ParseIP("127.0.0.1")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	go func() {
		data := make([]byte, 1024)
		for {
			n, remoteAddr, err := conn.ReadFromUDP(data)
			if err != nil {
				fmt.Printf("error during read: %s", err)
			}
			fmt.Printf("&lt;%s&gt; %s\n", remoteAddr, data[:n])
		}
	}()
	conn.Write([]byte("hello"))
	b := make([]byte, 1)
	os.Stdin.Read(b)
}</pre><p></p>
<p style="text-align: justify"><strong>6、</strong><br />
<code>*UDPConn</code>还有一个通用的<code>WriteMsgUDP(b, oob []byte, addr *UDPAddr)</code>，同时支持<code>connected</code>和<code>unconnected</code>的UDPConn:</p>
<ol style="text-align: justify">
<li>如果<code>UDPConn</code>还未连接，那么它会发送数据报给addr</li>
<li>如果<code>UDPConn</code>已连接，那么它会发送数据报给连接的对端，这种情况下addr应该为nil</li>
</ol>
<h2 id="通用多播编程" style="text-align: justify">通用多播编程</h2>
<p style="text-align: justify">Go标准库也支持多播，但是我们首先我们看通用的多播是如何实现的，它使用<code>golang.org/x/net/ipv4</code>或者<code>golang.org/x/net/ipv6</code>进行控制。</p>
<p style="text-align: justify">首先找到要进行多播所使用的网卡,然后监听本机合适的地址和服务端口。<br />
将这个应用加入到多播组中，它就可以从组中监听包信息，当然你还可以对包传输进行更多的控制设置。<br />
应用收到包后还可以检查包是否来自这个组的包。</p>
<p style="text-align: justify">完整的代码如下：</p>
<p></p><pre class="crayon-plain-tag">package main
import (
	"fmt"
	"net"
	"golang.org/x/net/ipv4"
)
func main() {
	//1. 得到一个interface
	en4, err := net.InterfaceByName("en4")
	if err != nil {
		fmt.Println(err)
	}
	group := net.IPv4(224, 0, 0, 250)
	//2. bind一个本地地址
	c, err := net.ListenPacket("udp4", "0.0.0.0:1024")
	if err != nil {
		fmt.Println(err)
	}
	defer c.Close()
	//3.
	p := ipv4.NewPacketConn(c)
	if err := p.JoinGroup(en4, &amp;net.UDPAddr{IP: group}); err != nil {
		fmt.Println(err)
	}
	//4.更多的控制
	if err := p.SetControlMessage(ipv4.FlagDst, true); err != nil {
		fmt.Println(err)
	}
	//5.接收消息
	b := make([]byte, 1500)
	for {
		n, cm, src, err := p.ReadFrom(b)
		if err != nil {
			fmt.Println(err)
		}
		if cm.Dst.IsMulticast() {
			if cm.Dst.Equal(group) {
				fmt.Printf("received: %s from &lt;%s&gt;\n", b[:n], src)
				n, err = p.WriteTo([]byte("world"), cm, src)
				if err != nil {
					fmt.Println(err)
				}
			} else {
				fmt.Println("Unknown group")
				continue
			}
		}
	}
}</pre><p></p>
<p style="text-align: justify">同一个应用可以加入到多个组中，多个应用也可以加入到同一个组中。<br />
多个UDP listener可以监听同样的端口，加入到同一个group中。</p>
<blockquote><p>It is possible for multiple UDP listeners that listen on the same UDP port to join the same multicast group. The net package will provide a socket that listens to a wildcard address with reusable UDP port when an appropriate multicast address prefix is passed to the net.ListenPacket or net.ListenUDP.</p></blockquote>
<p></p><pre class="crayon-plain-tag">c1, err := net.ListenPacket("udp4", "224.0.0.0:1024")
if err != nil {
	// error handling
}
defer c1.Close()
c2, err := net.ListenPacket("udp4", "224.0.0.0:1024")
if err != nil {
	// error handling
}
defer c2.Close()
p1 := ipv4.NewPacketConn(c1)
if err := p1.JoinGroup(en0, &amp;net.UDPAddr{IP: net.IPv4(224, 0, 0, 248)}); err != nil {
	// error handling
}
p2 := ipv4.NewPacketConn(c2)
if err := p2.JoinGroup(en0, &amp;net.UDPAddr{IP: net.IPv4(224, 0, 0, 248)}); err != nil {
	// error handling
}</pre><p></p>
<p style="text-align: justify">还支持<code>Source-specific multicasting</code>特性。</p>
<h2 id="标准库多播编程" style="text-align: justify">标准库多播编程</h2>
<p style="text-align: justify">标准库的多播编程简化了上面的操作，当然也减少了更多的控制。如果想实现一个简单的多播程序，可以使用这样的方法。</p>
<p style="text-align: justify">服务器端的代码：</p>
<p></p><pre class="crayon-plain-tag">func main() {
	//如果第二参数为nil,它会使用系统指定多播接口，但是不推荐这样使用
	addr, err := net.ResolveUDPAddr("udp", "224.0.0.250:9981")
	if err != nil {
		fmt.Println(err)
	}
	listener, err := net.ListenMulticastUDP("udp", nil, addr)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Local: &lt;%s&gt; \n", listener.LocalAddr().String())
	data := make([]byte, 1024)
	for {
		n, remoteAddr, err := listener.ReadFromUDP(data)
		if err != nil {
			fmt.Printf("error during read: %s", err)
		}
		fmt.Printf("&lt;%s&gt; %s\n", remoteAddr, data[:n])
	}
}</pre><p></p>
<p style="text-align: justify">写个客户端测试一下：</p>
<p></p><pre class="crayon-plain-tag">func main() {
	ip := net.ParseIP("224.0.0.250")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.DialUDP("udp", srcAddr, dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	defer conn.Close()
	conn.Write([]byte("hello"))
	fmt.Printf("&lt;%s&gt;\n", conn.RemoteAddr())}</pre><p></p>
<h2 id="广播" style="text-align: justify">广播</h2>
<p style="text-align: justify">广播的编程方式和多播的编程方式有所不同。简单说，广播意味着你吼一嗓子，局域网内的所有的机器都会收到。</p>
<p style="text-align: justify">服务器端代码：</p>
<p></p><pre class="crayon-plain-tag">func main() {
	listener, err := net.ListenUDP("udp", &amp;net.UDPAddr{IP: net.IPv4zero, Port: 9981})
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("Local: &lt;%s&gt; \n", listener.LocalAddr().String())
	data := make([]byte, 1024)
	for {
		n, remoteAddr, err := listener.ReadFromUDP(data)
		if err != nil {
			fmt.Printf("error during read: %s", err)
		}
		fmt.Printf("&lt;%s&gt; %s\n", remoteAddr, data[:n])
		_, err = listener.WriteToUDP([]byte("world"), remoteAddr)
		if err != nil {
			fmt.Printf(err.Error())
		}
	}
}</pre><p></p>
<p style="text-align: justify">客户端代码有所不同，它不是通过<code>DialUDP</code> “连接” 广播地址，而是通过<code>ListenUDP</code>创建一个<code>unconnected</code>的 <code>*UDPConn</code>,然后通过<code>WriteToUDP</code>发送数据报，这和你脑海中的客户端不太一致：</p>
<p></p><pre class="crayon-plain-tag">func main() {
	ip := net.ParseIP("172.24.14.255")
	srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0}
	dstAddr := &amp;net.UDPAddr{IP: ip, Port: 9981}
	conn, err := net.ListenUDP("udp", srcAddr)
	if err != nil {
		fmt.Println(err)
	}
	n, err := conn.WriteToUDP([]byte("hello"), dstAddr)
	if err != nil {
		fmt.Println(err)
	}
	data := make([]byte, 1024)
	n, _, err = conn.ReadFrom(data)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Printf("read %s from &lt;%s&gt;\n", data[:n], conn.RemoteAddr())
	b := make([]byte, 1)
	os.Stdin.Read(b)
}</pre><p></p>
<p style="text-align: justify">你局域网内的广播地址可能和例子中的不同，你可以通过<code>ifconfig</code>查看。</p>
<p style="text-align: justify">广播地址(Broadcast Address)是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。</p>
<h2 id="任播" style="text-align: justify">任播</h2>
<p style="text-align: justify">在互联网中，通常使用边界网关协议来实现任播。比如域名根服务器就是通过任播的方式提供。13台根服务器使用13个任播地址，但是有500多台实际服务器。你可以通过单播的方式发送数据包，只有最快的(最近的)的一个UDP服务器接收到。</p>
<p style="text-align: justify">Anycasting最初是在RFC1546中提出并定义的，它的最初语义是，在IP网络上通过一个Anycast地址标识一组提供特定服务的主机，同时服务访问方并不关心提供服务的具体是哪一台主机(比如DNS或者镜像服务)，访问该地址的报文可以被IP网络路由到这一组目标中的任何一台主机上，它提供的是一种无状态的、尽力而为的服务。</p>
<p style="text-align: justify">RFC2373(IP Version 6 Addressing Architecture, July 1998)提供了较新的说明和动机：任播地址的一个期望应用是标识属于某个提供互联网服务的机构的路由器集合。这种地址可以用作IPv6路由标题的中间地址,使数据分组通过某一聚合或聚合序列传递。其他可能的用途是标识属于某一子网的路由器组或提供进入某一路由范围入口的路由器组。</p>
<p style="text-align: justify">RFC2373标准对任播的定义是，当一个单播地址被分配到多于一个的接口上时，发到该接口的报文被网络路由到由路由协议度量的“最近”的目标接口上。与Unicast和Multicast类似，Anycast也是IP网络的一种通信模式。Unicast允许源结点向单一目标结点发送数据报，Multicast允许源结点向一组目标结点发送数据报，而Anycast则允许源结点向一组目标结点中的一个结点发送数据报，而这个结点由路由系统选择，对源结点透明；同时，路由系统选择“最近”的结点为源结点提供服务，从而在一定程序上为源结点提供了更好的服务也减轻了网络负载。</p>
<h2 id="参考文档" style="text-align: justify">参考文档</h2>
<ol>
<li style="text-align: justify"><a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">https://zh.wikipedia.org/wiki/用户数据报协议</a></li>
<li style="text-align: justify"><a href="https://golang.org/pkg/net/" target="_blank" rel="external">https://golang.org/pkg/net/</a></li>
<li style="text-align: justify"><a href="http://man7.org/linux/man-pages/man7/udp.7.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man7/udp.7.html</a></li>
<li style="text-align: justify"><a href="https://godoc.org/golang.org/x/net/ipv4" target="_blank" rel="external">https://godoc.org/golang.org/x/net/ipv4</a></li>
<li style="text-align: justify"><a href="https://github.com/golang/go/issues/13391" target="_blank" rel="external">https://github.com/golang/go/issues/13391</a></li>
<li style="text-align: justify"><a href="http://baike.baidu.com/view/473043.htm" target="_blank" rel="external">http://baike.baidu.com/view/473043.htm</a></li>
<li style="text-align: justify"><a href="http://baike.baidu.com/view/2032315.htm" target="_blank" rel="external">http://baike.baidu.com/view/2032315.htm</a></li>
</ol>
<p><a href="http://blog.jobbole.com/107004/">深入Go UDP编程</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/107004/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>测试自动化后，我们还需要QA吗？</title>
		<link>http://blog.jobbole.com/106995/</link>
		<comments>http://blog.jobbole.com/106995/#respond</comments>
		<pubDate>Mon, 24 Oct 2016 03:48:03 +0000</pubDate>
		<dc:creator><![CDATA[ABOER]]></dc:creator>
				<category><![CDATA[IT技术]]></category>
		<category><![CDATA[QA]]></category>
		<category><![CDATA[测试]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=106995</guid>
		<description><![CDATA[<p>QA的职责 我们先讨论一下传统的瀑布模型下QA是如何工作的，其中最主要的问题是什么；然后作为对比，我们来看看在敏捷团队里QA又是如何工作的，工作重点又是什么；最后，我们详细看一看在新的职责下，QA应该如何做。 </p><p><a href="http://blog.jobbole.com/106995/">测试自动化后，我们还需要QA吗？</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<h2 style="text-align: justify">QA的职责</h2>
<p style="text-align: justify">我们先讨论一下传统的瀑布模型下QA是如何工作的，其中最主要的问题是什么；然后作为对比，我们来看看在敏捷团队里QA又是如何工作的，工作重点又是什么；最后，我们详细看一看在新的职责下，QA应该如何做。</p>
<h3 style="text-align: justify">瀑布开发模型</h3>
<p style="text-align: justify">即使在今天，在很多企业中，瀑布模型仍然是主流。每一个需求都需要经过分析，设计，开发，测试，上线部署，运维等阶段。虽然一些企业已经在实施<code>敏捷开发</code>，比如项目/产品以迭代的方式运作，也有诸如每日站会，代码检视等敏捷实践，但是如果仔细审视，你会发现其实<em>开发模式</em>骨子里还是瀑布：按照软件组件划分的部门结构（详见康威定律），按照职能划分的团队（开发和测试分属不同部门），过长的反馈周期，永远无法摆脱的集成难题等等。</p>
<p style="text-align: justify">随着软件变得越来越复杂，团队里没有任何一个人可以说出系统是如何运作的，也不知道最终用户是谁，以及最终用户会以何种方式来使用最终的软件。</p>
<p style="text-align: justify">更糟糕的是，按照职能划分的团队在物理上都是隔离的，比如独立的测试部门，独立的运维部门，整日忙碌而难以预约到档期的业务人员，当然还有经常疲于交付，无处吐槽的<em>苦逼</em>开发。由于这些隔离，信息的反馈周期会非常长，一个本来很容易修复的缺陷可能在4周之后才可能被另一个部门的测试发现，然后通过复杂的工作流（比如某种形式的缺陷追踪系统）流到开发那里，而开发可能还在拼命的完成早就应该交付的功能，从而形成恶性循环。</p>
<h3 style="text-align: justify">瀑布模式中的QA</h3>
<p style="text-align: justify">在这样的环境中，QA们能做的事情非常有限。在需求开始时会他们参加需求澄清的会议，制定一些<code>测试计划</code>，然后进行测试用例的设计。有的企业会用诸如Excel之类的工具来记录这些用例。这些写在Excel里的，<code>死</code>的用例用处非常有限。而最大的问题在于：它们无法<code>自动化执行</code>。另外，在实际软件开发中，需求总是会经常发生变化，需求的优先级也会有调整，然后这些记录在Excel中的<code>死</code>的用例会很快过期，变得无人问津。</p>
<p style="text-align: justify">除此之外，QA中的有些成员会使用工具来录制一些UI测试的场景，然后在每个新版本出来之后进行回放即可。然而，当UI发生一点变化之后，这些自动化的用例就会失效：比如<code>HTML</code>片段中元素位置的调整，<code>JavaScript</code>的异步调用超时等等。</p>
<p style="text-align: justify">显然，这种单纯以黑盒的形式来<strong>检查功能点</strong>的测试方式是不工作的，要真正有效的提升软件质量，仅仅通过<strong>事后检查</strong>是远远不够的，软件的质量也应该内建于软件之中。QA的工作也应该是一个贯穿软件生命周期的活动，从商业想法，到真实上线，这其中的所有环节，都应该有QA的参与。</p>
<h3 style="text-align: justify">系统思考</h3>
<p style="text-align: justify">如果不从一个系统的角度来思考软件质量，就无法真正构建出健壮的、让业务和团队都有信心的软件系统。<strong><em>质量从来都不只是QA的职责，而是整个团队的职责。</em></strong></p>
<p style="text-align: justify">关于软件质量，一个根深蒂固的误解是：缺陷在开发过程中被引入，然后在测试阶段被发现，最后在QA和开发的来来回回的撕扯中被解决（或者数量被大规模降低），最后在生产环境中，就只会有很少的，优先级很低的缺陷。</p>
<p style="text-align: justify">然而事实上，很多需求就没有仔细分析，业务价值不很确定，验收条件模糊，流入开发后又会引入一些代码级别的错误，以及业务规则上的缺陷，测试阶段会漏掉一些功能点，上线之后更是问题百出（网络故障，缓存失效，黑客攻击，操作系统补丁，甚至内存溢出，log文件将磁盘写满等等）。</p>
<p style="text-align: justify">在一个敏捷团队中，<strong>每个个人都应该对质量负责</strong>，而QA则以自己的丰富经验和独特视角来发掘系统中可能的质量隐患，并帮助团队将这些隐患消除。</p>
<p style="text-align: justify"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/7ce9575ac8edc990737f81ec5d2edef3.png"><img class="alignnone size-full wp-image-106998" src="http://jbcdn2.b0.upaiyun.com/2016/10/7ce9575ac8edc990737f81ec5d2edef3.png" alt="circle-resized" /></a></p>
<p style="text-align: justify">我在ThoughtWorks的同事<code>Anand Bagmar</code>在他的演讲What is Agile testing- How does automation help?中详细讨论过这部分内容。</p>
<h3 style="text-align: justify">QA到底应该干什么？</h3>
<p style="text-align: justify">本质上来说，任何软件项目的目标都应该是：<strong>更快地将<code>高质量</code>的软件从想法变成产品</strong>。</p>
<p style="text-align: justify">将这个大目标细分一下，会得到这样几个子项，即企业需要：</p>
<ul style="text-align: justify">
<li>更多的商业回报（发掘业务价值）</li>
<li>更快的上线时间（做最简单，直接的版本）</li>
<li>更好的软件质量（质量内嵌）</li>
<li>更少的资源投入（减少浪费）</li>
</ul>
<p style="text-align: justify">其实就是传说中的<strong>多、快、好、省</strong>。如果说这是每一个软件项目的目标的话，那么团队里的每一个个人都应该向着这个目标而努力，任何其他形式的工作都可以归类为<code>浪费</code>。用Excel记录那些经常会失效，而且无法自动执行的测试用例是浪费，会因为页面布局变化而大面积失效的UI测试也是浪费，一个容易修复的缺陷要等到数周之后才被发现也是浪费。</p>
<p style="text-align: justify">在这个大前提下，我们再来思考QA在团队里应该做什么以及怎么做。</p>
<h3 style="text-align: justify">QA的职责</h3>
<p style="text-align: justify">Lisa Crispin在《敏捷软件测试》中提到过一个很著名的模型：敏捷测试四象限。这个模型是QA制定测试策略时的一个重要参考：</p>
<p style="text-align: justify"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/cb4067d9ef2fca1e7076f0b1c6d5fc91.png"><img class="alignnone size-full wp-image-106997" src="http://jbcdn2.b0.upaiyun.com/2016/10/cb4067d9ef2fca1e7076f0b1c6d5fc91.png" alt="agile-testing-quadrants" /></a></p>
<p style="text-align: justify">如果按照纵向划分的话，图中的活动，越向上越面向业务；越向下越面向技术。横向划分的话，往左是支撑团队；往右是评价产品。</p>
<p style="text-align: justify">其实简化一下，QA在团队里的工作，可以分为两大类：</p>
<ul style="text-align: justify">
<li>确保我们在<code>正确的</code>交付产品</li>
<li>确保我们交付了<code>正确的</code>产品</li>
</ul>
<p style="text-align: justify">根据这个四象限的划分，大部分团队可能都会从Q2起步：QA会和BA，甚至UX一起，从需求分析入手，进行需求分析，业务场景梳理，这时候没有具体的可以被测试的软件代码。不过这并不妨碍<strong>测试</strong>活动，比如一些纸上原型的设计（感谢刘海生供图）：</p>
<p style="text-align: justify"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/6cb2470f09470374c40feaf2ab222687.png"><img class="alignnone size-full wp-image-106999" src="http://jbcdn2.b0.upaiyun.com/2016/10/6cb2470f09470374c40feaf2ab222687.png" alt="prototype-resized" /></a></p>
<p style="text-align: justify">通过这一阶段之后，我们已经有了用户故事，这时候QA需要和开发一起编写用户故事的自动化验收测试。当开发交付一部分功能之后，QA就可以做常规的用户故事测试，几个迭代之后，QA开始进行跨功能需求测试和探索性测试等。根据探索性测试的结果，QA可能会调整测试策略，调整测试优先级，完善测试用例等等。</p>
<p style="text-align: justify">根据项目的不同，团队可以从不同的象限开始测试策略的制定。事实上，Q1-Q4仅仅是一个编号，与时间、阶段并无关系，Lisa Crispin还专门撰文解释过。</p>
<p style="text-align: justify">关于QA如何在软件分析的上游就介入，然后通过BDD的方式与业务分析师一起产出软件的各种规格描述，并通过实例的方式来帮助整个团队对需求的理解，ThoughtWorks的林冰玉有一篇文章很好的介绍了BDD的正确做法。如果将QA的外延扩展到在线的生产环境，制定合理的测量指标，调整测试策略，强烈推荐林冰玉写的另一篇文章产品环境中的QA。</p>
<h4 style="text-align: justify">其他职责</h4>
<p style="text-align: justify">事实上，软件生命周期中有很多的活动，有很多处于<code>灰色</code>地段。既可以说是应该开发做，又可以说应该QA做，甚至可以推给其他角色（比如OPs）。不过我们知道，一旦涉及角色，人们就再也不会按照<code>全局优化</code>的思路来应对问题了。这种<code>灰色</code>的活动包括：</p>
<ul style="text-align: justify">
<li>持续集成的搭建</li>
<li>测试环境的创建于维护</li>
<li>UAT上的数据准备</li>
<li>代码中的测试代码的维护</li>
<li>测试代码的重构</li>
</ul>
<p style="text-align: justify">在团队实践中，这些活动我们通常会让QA和开发或者OPs同事一起结对来完成。一方面避免知识孤岛的形成，另一方面在跨角色的工作中，也可以激发出更多不同的思路。</p>
<h3 style="text-align: justify">万能的QA？</h3>
<p style="text-align: justify">虽然在这些活动中，QA都会参与，但是并不是说团队里只要有一个QA就可以了。QA在参与这些活动时，侧重点还是有很大不同的。</p>
<p style="text-align: justify">比如需求分析阶段，如果有QA的加入，一些从QA角度可以发现的有明显缺陷的场景，则可以在分析阶段就得到很好的处理。另一方面，尽早介入可以设计出更合理的测试计划（比如哪些功能的优先级比较高，用户更会频繁使用，那么对应的测试比重也会更高）。在Story分析与书写阶段，QA可以帮助写出更加合理的验收条件，既满足业务需求，又可以很好的指导开发。</p>
<p style="text-align: justify">在和开发一起编写澄清需求时，主要是编写自动化验收测试，而不是实际编写业务逻辑的实现（虽然QA应该参与<code>Code Reivew</code>环节，学习并分享自己的观点）；甚至在上线运维阶段，QA还需要和OPs一起来设计用户数据的采集指标（比如用户访问的关键路径，浏览器版本，地区的区分等），从而制定出新的测试策略。</p>
<h3 style="text-align: justify">扩展阅读</h3>
<p><a href="http://www.slideshare.net/abagmar/what-is-agile-testing-how-does-automation-help">What is Agile testing &#8211; How does automation help?</a></p>
<p><a href="http://insights.thoughtworkers.org/agile-showcase-se7en/">敏捷实践Showcase的七宗罪</a></p>
<p><a href="http://www.jianshu.com/p/20b454a88bdb">产品环境下的QA</a></p>
<p><a href="https://book.douban.com/subject/5338399/">《敏捷软件测试》</a></p>
<p><a href="http://blog.jobbole.com/106995/">测试自动化后，我们还需要QA吗？</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/106995/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>C++ 文件操作详解</title>
		<link>http://blog.jobbole.com/106992/</link>
		<comments>http://blog.jobbole.com/106992/#respond</comments>
		<pubDate>Mon, 24 Oct 2016 03:17:54 +0000</pubDate>
		<dc:creator><![CDATA[中二饼]]></dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[C语言]]></category>
		<category><![CDATA[文件]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=106992</guid>
		<description><![CDATA[<p>本文详细介绍了C++的文件操作</p><p><a href="http://blog.jobbole.com/106992/">C++ 文件操作详解</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p>C++ 通过以下几个类支持文件的输入输出：</p>
<ul>
<li>ofstream: 写操作（输出）的文件类 (由ostream引申而来)</li>
<li>ifstream: 读操作（输入）的文件类(由istream引申而来)</li>
<li>fstream: 可同时读写操作的文件类 (由iostream引申而来)</li>
</ul>
<h3>打开文件(Open a file)</h3>
<p>对这些类的一个对象所做的第一个操作通常就是将它和一个真正的文件联系起来，也就是说打开一个文件。被打开的文件在程序中由一个流对象(stream object)来表示 (这些类的一个实例) ，而对这个流对象所做的任何输入输出操作实际就是对该文件所做的操作。</p>
<p>要通过一个流对象打开一个文件，我们使用它的成员函数open()：void open (const char * filename, openmode mode);</p>
<p>这里filename 是一个字符串，代表要打开的文件名，mode 是以下标志符的一个组合： ios::in 为输入(读)而打开文件</p>
<ul>
<li>ios::out 为输出(写)而打开文件</li>
<li>ios::ate 初始位置：文件尾</li>
<li>ios::app 所有输出附加在文件末尾</li>
<li>ios::trunc 如果文件已存在则先删除该文件</li>
<li>ios::binary 二进制方式</li>
</ul>
<p>这些标识符可以被组合使用，中间以”或”操作符(|)间隔。例如，如果我们想要以二进制方式打开文件&#8221;example.bin&#8221; 来写入一些数据，我们可以通过以下方式调用成员函数open（）来实现：</p><pre class="crayon-plain-tag">ofstream file;
file.open ("example.bin", ios::out | ios::app | ios::binary);</pre><p>ofstream, ifstream 和 fstream所有这些类的成员函数open 都包含了一个默认打开文件的方式，这三个类的默认方式各不相同： 类 参数的默认方式</p>
<ul>
<li>ofstream ios::out | ios::trunc</li>
<li>ifstream ios::in</li>
<li>fstream ios::in | ios::out</li>
</ul>
<p>只有当函数被调用时没有声明方式参数的情况下，默认值才会被采用。如果函数被调用时声明了任何参数，默认值将被完全改写，而不会与调用参数组合。</p>
<p>由 于对类ofstream, ifstream 和 fstream 的对象所进行的第一个操作通常都是打开文件，这些类都有一个构造函数可以直接调用open 函数，并拥有同样的参数。这样，我们就可以通过以下方式进行与上面同样的定义对象和打开文件的操作：</p><pre class="crayon-plain-tag">ofstream file ("example.bin", ios::out | ios::app | ios::binary);</pre><p>两种打开文件的方式都是正确的。</p>
<p>你可以通过调用成员函数is_open()来检查一个文件是否已经被顺利的打开了：bool is_open();</p>
<p>它返回一个布尔(bool)值，为真（true）代表文件已经被顺利打开，假( false )则相反。</p>
<h3>关闭文件(Closing a file)</h3>
<p>当文件读写操作完成之后，我们必须将文件关闭以使文件重新变为可访问的。关闭文件需要调用成员函数close()，它负责将缓存中的数据排放出来并关闭文件。它的格式很简单：</p><pre class="crayon-plain-tag">void close ();</pre><p>这个函数一旦被调用，原先的流对象(stream object)就可以被用来打开其它的文件了，这个文件也就可以重新被其它的进程(process)所有访问了。</p>
<p>为防止流对象被销毁时还联系着打开的文件，析构函数(destructor)将会自动调用关闭函数close。</p>
<h3>文本文件(Text mode files)</h3>
<p>类ofstream, ifstream 和fstream 是分别从ostream, istream 和iostream 中引申而来的。这就是为什么 fstream 的对象可以使用其父类的成员来访问数据。</p>
<p>一般来说，我们将使用这些类与同控制台(console)交互同样的成员函数(cin 和 cout)来进行输入输出。如下面的例题所示，我们使用重载的插入操作符</p>
<div>
<pre class="crayon-plain-tag">// writing on a text file
#include &lt;fstream&gt;
using namespace std;

int main()
{
    ofstream examplefile("example.txt");
    if (examplefile.is_open())
    {
        examplefile &lt;&lt; "This is a line.\n";
        examplefile &lt;&lt; "This is another line.\n";
        examplefile.close();
    }
    return 0;
}</pre>
</div>
<p>从文件中读入数据也可以用与 cin的使用同样的方法：</p>
<div>
<pre class="crayon-plain-tag">// reading a text file
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;
using namespace std;
int main ()
{
    char buffer[256];
    ifstream examplefile("example.txt");
    if (! examplefile.is_open())
    {
        cout &lt;&lt; "Error opening file"; exit (1);
    }
    while (!examplefile.eof())
    {
        examplefile.getline(buffer,100);
        cout&lt;&lt;buffer&lt;&lt; endl;
    }
    return 0;
}
//This is a line.
//This is another line.</pre>
</div>
<p>上面的例子读入一个文本文件的内容，然后将它打印到屏幕上。注意我们使用了一个新的成员函数叫做eof ，它是ifstream 从类 ios 中继承过来的，当到达文件末尾时返回true 。</p>
<h3>状态标志符的验证(Verification of state flags)</h3>
<p>除了eof()以外，还有一些验证流的状态的成员函数（所有都返回bool型返回值）：</p>
<p>bad()</p>
<ul>
<li>如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。</li>
</ul>
<p>fail()</p>
<ul>
<li>除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。</li>
</ul>
<p>eof()</p>
<ul>
<li>如果读文件到达文件末尾，返回true。</li>
</ul>
<p>good()</p>
<ul>
<li>这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。</li>
</ul>
<p>要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。</p>
<p>获得和设置流指针(get and put stream pointers)</p>
<p>所有输入/输出流对象(i/o streams objects)都有至少一个流指针：</p>
<ul>
<li>ifstream， 类似istream, 有一个被称为get pointer的指针，指向下一个将被读取的元素。</li>
<li>ofstream, 类似 ostream, 有一个指针 put pointer ，指向写入下一个元素的位置。</li>
<li>fstream, 类似 iostream, 同时继承了get 和 put</li>
</ul>
<p>我们可以通过使用以下成员函数来读出或配置这些指向流中读写位置的流指针：</p>
<p>tellg() 和 tellp()</p>
<ul>
<li>这两个成员函数不用传入参数，返回pos_type 类型的值(根据ANSI-C++ 标准) ，就是一个整数，代表当前get 流指针的位置 (用tellg) 或 put 流指针的位置(用tellp).</li>
</ul>
<p>seekg() 和seekp()</p>
<ul>
<li>这对函数分别用来改变流指针get 和put的位置。两个函数都被重载为两种不同的原型：<br />
<pre class="crayon-plain-tag">seekg ( pos_type position );
seekp ( pos_type position );</pre>
</li>
</ul>
<p>使用这个原型，流指针被改变为指向从文件开始计算的一个绝对位置。要求传入的参数类型与函数 tellg 和tellp 的返回值类型相同。</p><pre class="crayon-plain-tag">seekg ( off_type offset, seekdir direction );
seekp ( off_type offset, seekdir direction );</pre><p>使用这个原型可以指定由参数direction决定的一个具体的指针开始计算的一个位移(offset)。它可以是：</p>
<ul>
<li>ios::beg 从流开始位置计算的位移</li>
<li>ios::cur 从流指针当前位置开始计算的位移</li>
<li>ios::end 从流末尾处开始计算的位移</li>
</ul>
<p>流指针 get 和 put 的值对文本文件(text file)和二进制文件(binary file)的计算方法都是不同的，因为文本模式的文件中某些特殊字符可能被修改。由于这个原因，建议对以文本文件模式打开的文件总是使用seekg 和 seekp的第一种原型，而且不要对tellg 或 tellp 的返回值进行修改。对二进制文件，你可以任意使用这些函数，应该不会有任何意外的行为产生。</p>
<p>以下例子使用这些函数来获得一个二进制文件的大小：</p>
<div>
<pre class="crayon-plain-tag">// obtaining file size
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

int main ()
{
    const char * filename = "example.txt";
    long l,m;
    ifstream file(filename, ios::in|ios::binary);
    l = file.tellg();
    file.seekg(0, ios::end);
    m = file.tellg();
    file.close();
    cout &lt;&lt;"size of "&lt;&lt; filename;
    cout &lt;&lt;" is "&lt;&lt; (m-l)&lt;&lt;" bytes.\n";
    return 0;
}
//size of example.txt is 40 bytes.</pre>
</div>
<h3>二进制文件(Binary files)</h3>
<p>在二进制文件中，使用&gt;，以及函数（如getline）来操作符输入和输出数据，没有什么实际意义，虽然它们是符合语法的。</p>
<p>文 件流包括两个为顺序读写数据特殊设计的成员函数：write 和 read。第一个函数 (write) 是ostream 的一个成员函数，都是被ofstream所继承。而read 是istream 的一个成员函数，被ifstream 所继承。类 fstream 的对象同时拥有这两个函数。它们的原型是：</p><pre class="crayon-plain-tag">write ( char * buffer, streamsize size );
read ( char * buffer, streamsize size );</pre><p>这里 buffer 是一块内存的地址，用来存储或读出数据。参数size 是一个整数值，表示要从缓存（buffer）中读出或写入的字符数。</p>
<div>
<pre class="crayon-plain-tag">// reading binary file
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
int main ()
{
    const char * filename = "example.txt";
    char * buffer;
    long size;
    ifstream file(filename, ios::in|ios::binary|ios::ate);
    size = file.tellg();
    file.seekg(0, ios::beg);
    buffer = new char [size];
    file.read(buffer, size);
    file.close();
    cout &lt;&lt;"the complete file is in a buffer";
    delete[] buffer;
    return 0;
}
//The complete file is in a buffer</pre>
</div>
<h3>缓存和同步(Buffers and Synchronization)</h3>
<p>当我们对文件流进行操作的时候，它们与一个streambuf 类型的缓存(buffer)联系在一起。这个缓存（buffer）实际是一块内存空间，作为流(stream)和物理文件的媒介。例如，对于一个输出流， 每次成员函数put (写一个单个字符)被调用，这个字符不是直接被写入该输出流所对应的物理文件中的，而是首先被插入到该流的缓存（buffer）中。</p>
<p>当缓存被排放出来(flush)时，它里面的所有数据或者被写入物理媒质中（如果是一个输出流的话），或者简单的被抹掉(如果是一个输入流的话)。这个过程称为同步(synchronization)，它会在以下任一情况下发生：</p>
<ul>
<li>当文件被关闭时: 在文件被关闭之前，所有还没有被完全写出或读取的缓存都将被同步。</li>
<li>当缓存buffer 满时:缓存Buffers 有一定的空间限制。当缓存满时，它会被自动同步。</li>
<li>控制符明确指明:当遇到流中某些特定的控制符时，同步会发生。这些控制符包括：flush 和endl。</li>
</ul>
<p>明确调用函数sync(): 调用成员函数sync() (无参数)可以引发立即同步。这个函数返回一个int 值，等于-1 表示流没有联系的缓存或操作失败</p>
<p>在C++中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符：</p>
<h4>1、插入器(&lt;&lt;) <strong><br />
</strong></h4>
<h4>向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout</h4>
<h4>2、析取器(&gt;&gt;)</h4>
<p>从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。</p>
<p>在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。下面就把此类的文件操作过程一一道来。</p>
<h3>一、打开文件</h3>
<p>在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：</p><pre class="crayon-plain-tag">void open(const char* filename,int mode,int access);</pre><p>参数：</p>
<ul>
<li>filename： 要打开的文件名</li>
<li>mode： 要打开文件的方式</li>
<li>access： 打开文件的属性</li>
</ul>
<p>打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下：</p>
<ul>
<li>ios::app： 以追加的方式打开文件</li>
<li>ios::ate： 文件打开后定位到文件尾，ios:app就包含有此属性</li>
<li>ios::binary： 以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文</li>
<li>ios::in： 文件以输入方式打开</li>
<li>ios::out： 文件以输出方式打开</li>
<li>ios::nocreate： 不建立文件，所以文件不存在时打开失败</li>
<li>ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败</li>
<li>ios::trunc： 如果文件存在，把文件长度设为0</li>
</ul>
<p>可以用“或”把以上属性连接起来，如ios::out|ios::binary</p>
<p>打开文件的属性取值是：</p>
<p>0：普通文件，打开访问<br />
1：只读文件<br />
2：隐含文件<br />
4：系统文件</p>
<p>可以用“或”或者“+”把以上属性连接起来 ，如3或1|2就是以只读和隐含属性打开文件。</p>
<p>例如：以二进制输入方式打开文件c:config.sys</p>
<div>
<pre class="crayon-plain-tag">fstream file1;
file1.open("c:config.sys",ios::binary|ios::in,0);</pre>
</div>
<p>如果open函数只有文件名一个参数，则是以读/写普通文件打开，即：</p>
<div>
<pre class="crayon-plain-tag">file1.open("c:config.sys");&lt;=&gt;file1.open("c:config.sys",ios::in|ios::out,0);</pre>
</div>
<p>另外，fstream还有和open()一样的构造函数，对于上例，在定义的时侯就可以打开文件了：</p>
<div>
<pre class="crayon-plain-tag">fstream file1("c:config.sys");</pre>
</div>
<p>特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。</p>
<div>
<pre class="crayon-plain-tag">ifstream file2("c:pdos.def");//以输入方式打开文件
ofstream file3("c:x.123");//以输出方式打开文件</pre>
</div>
<p>所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。</p>
<h3>二、关闭文件</h3>
<p>打开的文件使用完成后一定要关闭，fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。</p>
<h3>三、读写文件</h3>
<p>读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式</p>
<p>1、文本文件的读写</p>
<p>文本文件的读写很简单：用插入器(&gt;)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下：</p>
<div>
<pre class="crayon-plain-tag">file2"I Love You";//向文件写入字符串"I Love You"
int i;
file1&gt;&gt;i;//从文件输入一个整数值。</pre>
</div>
<p>这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些</p>
<p>操纵符 功能 输入/输出<br />
dec 格式化为十进制数值数据 输入和输出<br />
endl 输出一个换行符并刷新此流 输出<br />
ends 输出一个空字符 输出<br />
hex 格式化为十六进制数值数据 输入和输出<br />
oct 格式化为八进制数值数据 输入和输出<br />
setpxecision(int p) 设置浮点数的精度位数 输出</p>
<p>比如要把123当作十六进制输出：file1&lt;&lt;hex&lt;&lt;123;要把3.1415926以5位精度输出：file1&lt;&lt;setpxecision(5)&lt;&lt;3.1415926。</p>
<p>2、二进制文件的读写</p>
<p>①put()</p>
<p>put()函数向流写入一个字符，其原型是ofstream &amp;put(char ch)，使用也比较简单，如file1.put(&#8216;c&#8217;);就是向流写一个字符&#8217;c&#8217;。</p>
<p>②get()</p>
<p>get()函数比较灵活，有3种常用的重载形式：</p>
<p>一种就是和put()对应的形式：ifstream &amp;get(char &amp;ch);功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如file2.get(x);表示从文件中读取一个字符，并把读取的字符保存在x中。</p>
<p>另一种重载形式的原型是： int get();这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如x=file2.get();和上例功能是一样的。</p>
<p>还 有一种形式的原型是：ifstream &amp;get(char *buf,int num,char delim=&#8217;n&#8217;)；这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符&#8217;n&#8217;。例如：</p>
<p>file2.get(str1,127,&#8217;A&#8217;);//从文件中读取字符到字符串str1，当遇到字符&#8217;A&#8217;或读取了127个字符时终止。</p>
<p>③读写数据块</p>
<p>要读写二进制数据块，使用成员函数read()和write()成员函数，它们原型如下：</p>
<div>
<pre class="crayon-plain-tag">read(unsigned char *buf,int num);
write(const unsigned char *buf,int num);</pre>
</div>
<p>read() 从文件中读取 num 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而 write() 从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 unsigned char *，有时可能需要类型转换。</p>
<p>例：</p>
<div>
<pre class="crayon-plain-tag">unsigned char str1[]="I Love You";
int n[5];
ifstream in("xxx.xxx");
ofstream out("yyy.yyy");
out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中
in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换
in.close();out.close();</pre>
</div>
<h3>四、检测 EOF</h3>
<p>成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();</p>
<p>例：</p>
<div>
<pre class="crayon-plain-tag">if(in.eof())ShowMessage("已经到达文件尾！");</pre>
</div>
<h3>五、文件定位</h3>
<p>和 C的文件操作方式不同的是，C++ I/O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时， 相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是 seekg()和 seekp()，seekg()是设置读位置，seekp是设置写位置。它们最通用的形式如下：</p>
<div>
<pre class="crayon-plain-tag">istream &amp;seekg(streamoff offset,seek_dir origin);
ostream &amp;seekp(streamoff offset,seek_dir origin);</pre>
</div>
<p>streamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举：</p>
<ul>
<li>ios::beg： 文件开头</li>
<li>ios::cur： 文件当前位置</li>
<li>ios::end： 文件结尾</li>
</ul>
<p>这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。</p>
<p>例：</p>
<div>
<pre class="crayon-plain-tag">file1.seekg(1234,ios::cur);//把文件的读指针从当前位置向后移1234个字节
file2.seekp(1234,ios::beg);//把文件的写指针从文件开头向后移1234个字节</pre>
</div>
<p><a href="http://blog.jobbole.com/106992/">C++ 文件操作详解</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/106992/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>漫画算法：最小栈的实现</title>
		<link>http://blog.jobbole.com/106940/</link>
		<comments>http://blog.jobbole.com/106940/#comments</comments>
		<pubDate>Mon, 24 Oct 2016 01:18:21 +0000</pubDate>
		<dc:creator><![CDATA[玻璃猫]]></dc:creator>
				<category><![CDATA[IT技术]]></category>
		<category><![CDATA[趣文小说]]></category>
		<category><![CDATA[漫画]]></category>
		<category><![CDATA[算法]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=106940</guid>
		<description><![CDATA[<p>实现一个栈，带有出栈（pop），入栈（push），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）。</p><p><a href="http://blog.jobbole.com/106940/">漫画算法：最小栈的实现</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p><a href="http://jbcdn2.b0.upaiyun.com/2016/10/8ae42f84471f17e60dce2ce576a2eb3f.jpg"><img class="size-full wp-image-106952 aligncenter" src="http://jbcdn2.b0.upaiyun.com/2016/10/8ae42f84471f17e60dce2ce576a2eb3f.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%841" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/316829ce22e6ed5d4bcc2b0c4860536f.jpg"><img class="alignnone size-full wp-image-106953" src="http://jbcdn2.b0.upaiyun.com/2016/10/316829ce22e6ed5d4bcc2b0c4860536f.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%842" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/0a8df0c9facab142cdc80e7dc59131e0.jpg"><img class="alignnone size-full wp-image-106954" src="http://jbcdn2.b0.upaiyun.com/2016/10/0a8df0c9facab142cdc80e7dc59131e0.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%843" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/ea47315ecf06f0d7667890a1d3141a82.jpg"><img class="alignnone size-full wp-image-106955" src="http://jbcdn2.b0.upaiyun.com/2016/10/ea47315ecf06f0d7667890a1d3141a82.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%844" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/74170d3e644cfcf79fc7a8880e49d255.jpg"><img class="alignnone size-full wp-image-106956" src="http://jbcdn2.b0.upaiyun.com/2016/10/74170d3e644cfcf79fc7a8880e49d255.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%845" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/41fcd113fb277fadd064632fb2623777.jpg"><img class="alignnone size-full wp-image-106957" src="http://jbcdn2.b0.upaiyun.com/2016/10/41fcd113fb277fadd064632fb2623777.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%847" /></a></p>
<p style="text-align: center;">小灰回忆起当时的情景&#8230;&#8230;</p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/494a8ce0a1a9a520a6fe68b99f795b40.jpg"><img class="alignnone size-full wp-image-106966" src="http://jbcdn2.b0.upaiyun.com/2016/10/494a8ce0a1a9a520a6fe68b99f795b40.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%951" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/2324d278497939859a891a216f7b18f1.jpg"><img class="alignnone size-full wp-image-106967" src="http://jbcdn2.b0.upaiyun.com/2016/10/2324d278497939859a891a216f7b18f1.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%952" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/3c955cd7662b55890537b5392cd14bab.jpg"><img class="alignnone size-full wp-image-106968" src="http://jbcdn2.b0.upaiyun.com/2016/10/3c955cd7662b55890537b5392cd14bab.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%953" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/27ed5f2ab244164c384081436349e76b.jpg"><img class="alignnone size-full wp-image-106969" src="http://jbcdn2.b0.upaiyun.com/2016/10/27ed5f2ab244164c384081436349e76b.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%954" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/790839b93ee93cf80d2b548dd3b6f75b.jpg"><img class="alignnone size-full wp-image-106970" src="http://jbcdn2.b0.upaiyun.com/2016/10/790839b93ee93cf80d2b548dd3b6f75b.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%955" /></a></p>
<p style="text-align: left;"><strong>题目：</strong>实现一个栈，带有出栈（pop），入栈（push），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）。</p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/acc78e3cf04bea42927e5ba645909a34.jpg"><img class="alignnone size-full wp-image-106971" src="http://jbcdn2.b0.upaiyun.com/2016/10/acc78e3cf04bea42927e5ba645909a34.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%956" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/7a8fccfcb1257b19bd0ba47f3d009f02.jpg"><img class="alignnone size-full wp-image-106972" src="http://jbcdn2.b0.upaiyun.com/2016/10/7a8fccfcb1257b19bd0ba47f3d009f02.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%957" /></a></p>
<p style="text-align: left;"><strong>小灰的想法：</strong></p>
<p style="text-align: left;">1.创建一个整型变量 min，初始值-1</p>
<p style="text-align: left;">2.当第一个元素进栈时，让min=0，即把唯一的元素当做最小值。</p>
<p style="text-align: left;">3.之后每当一个新元素近栈，让新元素和min指向位置的元素比较大小。如果Stack[min]大于新元素，则min等于新元素的下标；Stack[min]小于新元素，则不做改变。</p>
<p style="text-align: left;">4.当调用getMin方法的时候，直接返回min所指向位置的元素即可。</p>
<p style="text-align: left;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/d08013a63d894ee32bf62aa266a5a0dc.jpg"><img class="size-full wp-image-106980 aligncenter" src="http://jbcdn2.b0.upaiyun.com/2016/10/d08013a63d894ee32bf62aa266a5a0dc.jpg" alt="%e6%9c%80%e5%b0%8f%e6%a0%88%e7%9a%84%e5%ae%9e%e7%8e%b01" /></a></p>
<p style="text-align: left;">按这个思路，近栈、出栈、取最小值的时间复杂度都是O(1)，空间复杂度也是O(1)。</p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/dddfaf8a0726d563abc197545e6f6e9f.jpg"><img class="alignnone size-full wp-image-106973" src="http://jbcdn2.b0.upaiyun.com/2016/10/dddfaf8a0726d563abc197545e6f6e9f.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%958" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/2f7fdcadef2a7f1b1e85452b7117516e.jpg"><img class="alignnone size-full wp-image-106974" src="http://jbcdn2.b0.upaiyun.com/2016/10/2f7fdcadef2a7f1b1e85452b7117516e.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%959" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/7447c57f363cc8d753c612b44a67bf8c.jpg"><img class="alignnone size-full wp-image-106975" src="http://jbcdn2.b0.upaiyun.com/2016/10/7447c57f363cc8d753c612b44a67bf8c.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e9%9d%a2%e8%af%9510" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/73eb15b9459343611d4cbe8968fa62ea.jpg"><img class="alignnone size-full wp-image-106976" src="http://jbcdn2.b0.upaiyun.com/2016/10/73eb15b9459343611d4cbe8968fa62ea.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%a4%b1%e6%9c%9b" /></a></p>
<p style="text-align: center;">回忆到此结束&#8230;&#8230;</p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/571e5de957f7088283638f43593db252.jpg"><img class="alignnone size-full wp-image-106958" src="http://jbcdn2.b0.upaiyun.com/2016/10/571e5de957f7088283638f43593db252.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%848" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/8e0a309db9d81d06cb8bab0aaa068cf4.jpg"><img class="alignnone size-full wp-image-106959" src="http://jbcdn2.b0.upaiyun.com/2016/10/8e0a309db9d81d06cb8bab0aaa068cf4.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%849" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/d5ea6dc6278677d681ce35ce05b2fd8b.jpg"><img class="alignnone size-full wp-image-106960" src="http://jbcdn2.b0.upaiyun.com/2016/10/d5ea6dc6278677d681ce35ce05b2fd8b.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%8410" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/f03c45c988c2459a88d96b255d76a9c4.jpg"><img class="size-full wp-image-106978 aligncenter" src="http://jbcdn2.b0.upaiyun.com/2016/10/f03c45c988c2459a88d96b255d76a9c4.jpg" alt="%e6%9c%80%e5%b0%8f%e6%a0%88%e7%9a%84%e5%ae%9e%e7%8e%b02" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/18348defd98d4a16025b846a00c3895e.jpg"><img class="alignnone size-full wp-image-106961" src="http://jbcdn2.b0.upaiyun.com/2016/10/18348defd98d4a16025b846a00c3895e.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%8411" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/fb5d03aa4280313576b54d883a6ea878.jpg"><img class="alignnone size-full wp-image-106962" src="http://jbcdn2.b0.upaiyun.com/2016/10/fb5d03aa4280313576b54d883a6ea878.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%8412" /></a></p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/b11be4074aa94d979568375857c5bda9.jpg"><img class="alignnone size-full wp-image-106963" src="http://jbcdn2.b0.upaiyun.com/2016/10/b11be4074aa94d979568375857c5bda9.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%8413" /></a></p>
<p style="text-align: left;"><strong>解法：</strong></p>
<p style="text-align: left;">1.设原有的栈叫做栈A，此时创建一个额外的栈B，用于辅助原栈A。</p>
<p style="text-align: left;">2.当第一个元素进入栈A的时候，让新元素的下标进入栈B。这个唯一的元素是栈A的当前最小值。（考虑到栈中元素可能不是类对象，所以B栈存储的是A栈元素的下标）</p>
<p style="text-align: left;">3.每当新元素进入栈A时，比较新元素和栈A当前最小值的大小，如果小于栈A当前最小值，则让新元素的下标进入栈B，此时栈B的栈顶元素就是栈A当前最小值的下标。</p>
<p style="text-align: left;">4.每当栈A有元素出栈时，如果出栈元素是栈A当前最小值，则让栈B的栈顶元素也出栈。此时栈B余下的栈顶元素所指向的，是栈A当中原本第二小的元素，代替刚才的出栈元素成为了栈A的当前最小值。（备胎转正）</p>
<p style="text-align: left;">5.当调用getMin方法的时候，直接返回栈B的栈顶所指向的栈A对应元素即可。</p>
<p style="text-align: left;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/a835841ba894e06ab62623aeee04278a.jpg"><img class="size-full wp-image-106979 aligncenter" src="http://jbcdn2.b0.upaiyun.com/2016/10/a835841ba894e06ab62623aeee04278a.jpg" alt="%e6%9c%80%e5%b0%8f%e6%a0%88%e7%9a%84%e5%ae%9e%e7%8e%b03" /></a></p>
<p style="text-align: left;">这个解法中近栈、出栈、取最小值的时间复杂度都是O(1)，最坏情况空间复杂度是O(N)。</p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/c8361d77e379871a4d5a1fe8f0b163e3.jpg"><img class="alignnone size-full wp-image-106964" src="http://jbcdn2.b0.upaiyun.com/2016/10/c8361d77e379871a4d5a1fe8f0b163e3.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%8414" /></a></p>
<p style="text-align: left;"><strong>扩展题目：</strong></p>
<p style="text-align: left;">实现一个队列，带有出队（deQueue），入队（enQueue），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都尽可能小。</p>
<p style="text-align: center;"><a href="http://jbcdn2.b0.upaiyun.com/2016/10/243a88f6db9ebada238912356735ea25.jpg"><img class="alignnone size-full wp-image-106965" src="http://jbcdn2.b0.upaiyun.com/2016/10/243a88f6db9ebada238912356735ea25.jpg" alt="%e5%b0%8f%e4%bb%93%e9%bc%a0%e5%af%92%e6%9a%8415" /></a></p>
<p><a href="http://blog.jobbole.com/106940/">漫画算法：最小栈的实现</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/106940/feed/</wfw:commentRss>
		<slash:comments>25</slash:comments>
		</item>
		<item>
		<title>Go 中的锁源码实现：Mutex</title>
		<link>http://blog.jobbole.com/106981/</link>
		<comments>http://blog.jobbole.com/106981/#respond</comments>
		<pubDate>Mon, 24 Oct 2016 01:15:23 +0000</pubDate>
		<dc:creator><![CDATA[legendtkl]]></dc:creator>
				<category><![CDATA[Go]]></category>
		<category><![CDATA[开发]]></category>
		<category><![CDATA[mutex]]></category>
		<category><![CDATA[锁]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=106981</guid>
		<description><![CDATA[<p>golang 源码中的互斥锁实现探究。</p><p><a href="http://blog.jobbole.com/106981/">Go 中的锁源码实现：Mutex</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p>上一篇文章《<a class="archive-title" title="当我们谈论锁，我们谈什么" href="http://blog.jobbole.com/106582/" target="_blank"><span data-rel="title">当我们谈论锁，我们谈什么</span></a>》 中我提到了锁，准确地说是信号量（semaphore, mutext是semaphore的一种）的实现方式有两种：wait的时候忙等待或者阻塞自己。</p><pre class="crayon-plain-tag">//忙等待
wait(S) {
    while(S&lt;=0)
        ;   //no-op
    S--
}
//阻塞
wait(semaphore *S) {
    S-&gt;value--;
    if (S-&gt;value &lt; 0) {
        add this process to S-&gt;list;
        block()
    }
}</pre><p>忙等待和阻塞方式各有优劣：</p>
<ul>
<li>忙等待会使CPU空转，好处是如果在当前时间片内锁被其他进程释放，当前进程直接就能拿到锁而不需要CPU进行进程调度了。适用于锁占用时间较短的情况，且不适合于单处理器。</li>
<li>阻塞不会导致CPU空转，但是进程切换也需要代价，比如上下文切换，CPU Cache Miss。</li>
</ul>
<p>下面看一下golang的源码里面是怎么实现锁的。golang里面的锁有两个特性：<br />
1.不支持嵌套锁<br />
2.可以一个goroutine lock，另一个goroutine unlock</p>
<h2>互斥锁</h2>
<p>golang中的互斥锁定义在<code>src/sync/mutex.go</code></p><pre class="crayon-plain-tag">// A Mutex is a mutual exclusion lock.
// Mutexes can be created as part of other structures;
// the zero value for a Mutex is an unlocked mutex.
//
// A Mutex must not be copied after first use.
type Mutex struct {
    state int32
    sema  uint32
}

const (
    mutexLocked = 1 &lt;&lt; iota // mutex is locked
    mutexWoken
    mutexWaiterShift = iota
)</pre><p>看上去也是使用信号量的方式来实现的。sema就是信号量，一个非负数；state表示Mutex的状态。mutexLocked表示锁是否可用（0可用，1被别的goroutine占用），mutexWoken=2表示mutex是否被唤醒，mutexWaiterShift=2表示统计阻塞在该mutex上的goroutine数目需要移位的数值。将3个常量映射到state上就是</p><pre class="crayon-plain-tag">state:   |32|31|...|3|2|1|
         \__________/ | |
               |      | |
               |      | mutex的占用状态（1被占用，0可用）
               |      |
               |      mutex的当前goroutine是否被唤醒
               |
               当前阻塞在mutex上的goroutine数</pre><p></p>
<h4>1.Lock</h4>
<p>下面看一下mutex的lock。</p><pre class="crayon-plain-tag">func (m *Mutex) Lock() {
    // Fast path: grab unlocked mutex.
    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
        if race.Enabled {
            race.Acquire(unsafe.Pointer(m))
        }
        return
    }

    awoke := false
    iter := 0
    for {
        old := m.state
        new := old | mutexLocked
        if old&amp;mutexLocked != 0 {
            if runtime_canSpin(iter) {
                // Active spinning makes sense.
                // Try to set mutexWoken flag to inform Unlock
                // to not wake other blocked goroutines.
                if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                    awoke = true
                }
                runtime_doSpin()
                iter++
                continue
            }
            new = old + 1&lt;&lt;mutexWaiterShift
        }
        if awoke {
            // The goroutine has been woken from sleep,
            // so we need to reset the flag in either case.
            if new&amp;mutexWoken == 0 {
                panic("sync: inconsistent mutex state")
            }
            new &amp;^= mutexWoken
        }
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            if old&amp;mutexLocked == 0 {
                break
            }
            runtime_Semacquire(&amp;m.sema)
            awoke = true
            iter = 0
        }
    }

    if race.Enabled {
        race.Acquire(unsafe.Pointer(m))
    }
}</pre><p>这里要解释一下<code>atomic.CompareAndSwapInt32()</code>，<code>atomic</code>包是由golang提供的low-level的原子操作封装，主要用来解决进程同步为题，官方并不建议直接使用。我在上一篇文章中说过，操作系统级的锁的实现方案是提供原子操作，然后基本上所有锁相关都是通过这些原子操作来实现。<code>CompareAndSwapInt32()</code>就是int32型数字的<code>compare-and-swap</code>实现。cas(&amp;addr, old, new)的意思是<code>if *addr==old, *addr=new</code>。大部分操作系统支持CAS，x86指令集上的CAS汇编指令是<code>CMPXCHG</code>。下面我们继续看上面的lock函数。</p><pre class="crayon-plain-tag">if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
    if race.Enabled {
        race.Acquire(unsafe.Pointer(m))
    }
    return
}</pre><p>首先先忽略race.Enabled相关代码，这个是go做race检测时候用的，这个时候需要带上<code>-race</code>，则race.Enabled被置为true。Lock函数的入口处先调用CAS尝试去获得锁，如果m.state==0，则将其置为1，并返回。</p>
<p>继续往下看，首先将m.state的值保存到old变量中，new=old|mutexLocked。直接看能让for退出的第三个if条件，首先调用CAS试图将m.state设置成new的值。然后看一下if里面，如果m.state之前的值也就是old如果没有被占用则表示当前goroutine拿到了锁，则break。我们先看一下new的值的变化，第一个if条件里面<code>new = old + 1&lt;&lt;mutexWaiterShift</code>，结合上面的mutex的state各个位的意义，这句话的意思表示mutex的等待goroutine数目加1。还有awoke为true的情况下，要将m.state的标志位取消掉，也就是这句<code>new &amp;^= mutexWoken</code>的作用。继续看第三个if条件里面，如果里面的if判断失败，则走到runtime_Semacquire()。</p>
<p>看一下这个函数<code>runtime_Semacquire()</code>函数，由于golang1.5之后把之前C语言实现的代码都干掉了，所以现在很低层的代码都是go来实现的。通过源码中的定义我们可以知道这个其实就是信号量的wait操作：等待*s&gt;0，然后减1。编译器里使用的是<code>sync_runtime.semacquire()</code>函数。</p><pre class="crayon-plain-tag">// Semacquire waits until *s &gt; 0 and then atomically decrements it.
// It is intended as a simple sleep primitive for use by the synchronization
// library and should not be used directly.
func runtime_Semacquire(s *uint32)

//go:linkname sync_runtime_Semacquire sync.runtime_Semacquire
func sync_runtime_Semacquire(addr *uint32) {
    semacquire(addr, true)
}

func semacquire(addr *uint32, profile bool) {
    gp := getg()
    if gp != gp.m.curg {
        throw("semacquire not on the G stack")
    }

    // Easy case.
    if cansemacquire(addr) {
        return
    }

    // Harder case:
    //  increment waiter count
    //  try cansemacquire one more time, return if succeeded
    //  enqueue itself as a waiter
    //  sleep
    //  (waiter descriptor is dequeued by signaler)
    s := acquireSudog()
    root := semroot(addr)
    t0 := int64(0)
    s.releasetime = 0
    if profile &amp;&amp; blockprofilerate &gt; 0 {
        t0 = cputicks()
        s.releasetime = -1
    }
    for {
        lock(&amp;root.lock)
        // Add ourselves to nwait to disable "easy case" in semrelease.
        atomic.Xadd(&amp;root.nwait, 1)
        // Check cansemacquire to avoid missed wakeup.
        if cansemacquire(addr) {
            atomic.Xadd(&amp;root.nwait, -1)
            unlock(&amp;root.lock)
            break
        }
        // Any semrelease after the cansemacquire knows we're waiting
        // (we set nwait above), so go to sleep.
        root.queue(addr, s)
        goparkunlock(&amp;root.lock, "semacquire", traceEvGoBlockSync, 4)
        if cansemacquire(addr) {
            break
        }
    }
    if s.releasetime &gt; 0 {
        blockevent(s.releasetime-t0, 3)
    }
    releaseSudog(s)
}</pre><p>上面的代码有点多，我们只看和锁相关的代码。</p><pre class="crayon-plain-tag">root := semroot(addr)   //seg 1

atomic.Xadd(&amp;root.nwait, 1) // seg 2

root.queue(addr, s) //seg 3</pre><p>seg 1代码片段semroot()返回结构体semaRoot。存储方式是先对信号量的地址做移位，然后做哈希（对251取模，这个地方为什么是左移3位和对251取模不太明白）。semaRoot相当于和mutex.sema绑定。看一下semaRoot的结构：一个sudog链表和一个nwait整型字段。nwait字段表示该信号量上等待的goroutine数目。head和tail表示链表的头和尾巴，同时为了线程安全，需要使用一个互斥量来保护链表。这个时候细心的同学应该注意到一个问题，我们前面不是从Mutex跟过来的吗，相当于Mutex的实现了使用了Mutex本身？实际上semaRoot里面的mutex只是内部使用的一个简单版本，和sync.Mutex不是同一个。现在把这些倒推回去，<code>runtime_Semacquire()</code>的作用其实就是semaphore的wait(&amp;s)：如果*s&lt;0，则将当前goroutine塞入信号量s关联的goroutine waiting list，并休眠。</p><pre class="crayon-plain-tag">func semroot(addr *uint32) *semaRoot {
    return &amp;semtable[(uintptr(unsafe.Pointer(addr))&gt;&gt;3)%semTabSize].root
}

type semaRoot struct {
    lock  mutex
    head  *sudog
    tail  *sudog
    nwait uint32 // Number of waiters. Read w/o the lock.
}

// Prime to not correlate with any user patterns.
const semTabSize = 251

var semtable [semTabSize]struct {
    root semaRoot
    pad  [sys.CacheLineSize - unsafe.Sizeof(semaRoot{})]byte
}</pre><p>现在<code>mutex.Lock()</code>还剩下<code>runtime_canSpin(iter)</code>这一段，这个地方其实就是锁的自旋版本。golang对于自旋锁的取舍做了一些限制：1.多核; 2.GOMAXPROCS&gt;1; 3.至少有一个运行的P并且local的P队列为空。golang的自旋尝试只会做几次，并不会一直尝试下去，感兴趣的可以跟一下源码。</p><pre class="crayon-plain-tag">func sync_runtime_canSpin(i int) bool {
    // sync.Mutex is cooperative, so we are conservative with spinning.
    // Spin only few times and only if running on a multicore machine and
    // GOMAXPROCS&gt;1 and there is at least one other running P and local runq is empty.
    // As opposed to runtime mutex we don't do passive spinning here,
    // because there can be work on global runq on on other Ps.
    if i &gt;= active_spin || ncpu &lt;= 1 || gomaxprocs &lt;= int32(sched.npidle+sched.nmspinning)+1 {
        return false
    }
    if p := getg().m.p.ptr(); !runqempty(p) {
        return false
    }
    return true
}

func sync_runtime_doSpin() {
    procyield(active_spin_cnt)
}</pre><p></p>
<h4>Unlock</h4>
<p>Mutex的Unlock函数定义如下</p><pre class="crayon-plain-tag">// Unlock unlocks m.
// It is a run-time error if m is not locked on entry to Unlock.
//
// A locked Mutex is not associated with a particular goroutine.
// It is allowed for one goroutine to lock a Mutex and then
// arrange for another goroutine to unlock it.
func (m *Mutex) Unlock() {
    if race.Enabled {
        _ = m.state
        race.Release(unsafe.Pointer(m))
    }

    // Fast path: drop lock bit.
    new := atomic.AddInt32(&amp;m.state, -mutexLocked)
    if (new+mutexLocked)&amp;mutexLocked == 0 {
        panic("sync: unlock of unlocked mutex")
    }

    old := new
    for {
        // If there are no waiters or a goroutine has already
        // been woken or grabbed the lock, no need to wake anyone.
        if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken) != 0 {
            return
        }
        // Grab the right to wake someone.
        new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            runtime_Semrelease(&amp;m.sema)
            return
        }
        old = m.state
    }
}</pre><p>函数入口处的四行代码和race detection相关，暂时不用管。接下来的四行代码是判断是否是嵌套锁。new是m.state-1之后的值。我们重点看for循环内部的代码。</p><pre class="crayon-plain-tag">if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken) != 0 {
    return
}</pre><p>这两句是说：如果阻塞在该锁上的goroutine数目为0或者mutex处于lock或者唤醒状态，则返回。</p><pre class="crayon-plain-tag">new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
    runtime_Semrelease(&amp;m.sema)
    return
}</pre><p>这里先将阻塞在mutex上的goroutine数目减一，然后将mutex置于唤醒状态。<code>runtime_Semrelease</code>和<code>runtime_Semacquire</code>的作用刚好相反，将阻塞在信号量上goroutine唤醒。有人可能会问唤醒的是哪个goroutine，那么我们可以看一下goroutine wait list的入队列和出队列代码。</p><pre class="crayon-plain-tag">func (root *semaRoot) queue(addr *uint32, s *sudog) {
    s.g = getg()
    s.elem = unsafe.Pointer(addr)
    s.next = nil
    s.prev = root.tail
    if root.tail != nil {
        root.tail.next = s
    } else {
        root.head = s
    }
    root.tail = s
}

func (root *semaRoot) dequeue(s *sudog) {
    if s.next != nil {
        s.next.prev = s.prev
    } else {
        root.tail = s.prev
    }
    if s.prev != nil {
        s.prev.next = s.next
    } else {
        root.head = s.next
    }
    s.elem = nil
    s.next = nil
    s.prev = nil
}</pre><p>如上所示，wait list入队是插在队尾，出队是从头出。</p>
<h2>参考</h2>
<ul>
<li>《Go语言学习笔记》</li>
</ul>
<p><a href="http://blog.jobbole.com/106981/">Go 中的锁源码实现：Mutex</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/106981/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Linux 新的API signalfd、timerfd、eventfd使用说明</title>
		<link>http://blog.jobbole.com/106933/</link>
		<comments>http://blog.jobbole.com/106933/#respond</comments>
		<pubDate>Sun, 23 Oct 2016 14:46:11 +0000</pubDate>
		<dc:creator><![CDATA[lvyilong316]]></dc:creator>
				<category><![CDATA[IT技术]]></category>
		<category><![CDATA[Linux]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=106933</guid>
		<description><![CDATA[<p>传统的处理信号的方式是注册信号处理函数；由于信号是异步发生的，要解决数据的并发访问，可重入问题。signalfd可以将信号抽象为一个文件描述符，当有信号发生时可以对其read，这样可以将信号的监听放到select、poll、epoll等监听队列中。</p><p><a href="http://blog.jobbole.com/106933/">Linux 新的API signalfd、timerfd、eventfd使用说明</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p><b>三种新的fd加入linux内核的的版本：</b><b></b></p>
<p>signalfd：2.6.22</p>
<p>timerfd：2.6.25</p>
<p>eventfd：2.6.22</p>
<p><b>三种fd的意义：</b><b></b></p>
<p>l<b>s</b><b>ignalfd</b><b></b></p>
<p>传统的处理信号的方式是注册信号处理函数；由于信号是异步发生的，要解决数据的并发访问，可重入问题。signalfd可以将信号抽象为一个文件描述符，当有信号发生时可以对其read，这样可以将信号的监听放到select、poll、epoll等监听队列中。</p>
<p>l<b>timerfd</b><b></b></p>
<p>可以实现定时器的功能，将定时器抽象为文件描述符，当定时器到期时可以对其read，这样也可以放到监听队列的主循环中。</p>
<p>l<b>eventfd</b><b></b></p>
<p>实现了线程之间事件通知的方式，<b>也可以用于用户态和内核通信</b>。eventfd的缓冲区大小是sizeof(uint64_t)；向其write可以递增这个计数器，read操作可以读取，并进行清零；eventfd也可以放到监听队列中，当计数器不是0时，有可读事件发生，可以进行读取。</p>
<p>三种新的fd都可以进行监听，当有事件触发时，有可读事件发生。</p>
<h2><b>signalfd涉及API：</b></h2>
<div>
<div>
<p>点击(此处)折叠或打开</p><pre class="crayon-plain-tag">#include &lt;sys/signalfd.h&gt; 
int signalfd(int fd, const sigset_t *mask, int flags);</pre><p>
</p></div>
</div>
<p>参数fd：如果是-1则表示新建一个，如果是一个已经存在的则表示修改signalfd所关联的信号；</p>
<p>参数mask：信号集合；</p>
<p>参数flag：内核版本2.6.27以后支持SFD_NONBLOCK、SFD_CLOEXEC；</p>
<p>成功返回文件描述符，返回的fd支持以下操作：read、select(poll、epoll)、close</p>
<p>l<b>例子</b></p><pre class="crayon-plain-tag">#include &lt;sys/signalfd.h&gt; 
  #include &lt;signal.h&gt; 
  #include &lt;unistd.h&gt; 
  #include &lt;stdlib.h&gt; 
  #include &lt;stdio.h&gt; 
 
  #define handle_error(msg) \ 
  do { perror(msg); exit(EXIT_FAILURE); } while (0) 
 
  int main(int argc, char *argv[]) 
  { 
    sigset_t mask; 
    int sfd; 
    struct signalfd_siginfo fdsi; 
    ssize_t s; 
 
    sigemptyset(&amp;mask); 
    sigaddset(&amp;mask, SIGINT); 
    sigaddset(&amp;mask, SIGQUIT); 
 
    if (sigprocmask(SIG_BLOCK, &amp;mask, NULL) == -1) 
        handle_error("sigprocmask"); 
 
    sfd = signalfd(-1, &amp;mask, 0); 
    if (sfd == -1) 
        handle_error("signalfd"); 
 
    for (;;) { 
        s = read(sfd, &amp;fdsi, sizeof(struct signalfd_siginfo)); 
        if (s != sizeof(struct signalfd_siginfo)) 
            handle_error("read"); 
 
        if (fdsi.ssi_signo == SIGINT) { 
           printf("Got SIGINT\n"); 
        } else if (fdsi.ssi_signo == SIGQUIT) { 
        printf("Got SIGQUIT\n"); 
        exit(EXIT_SUCCESS); 
        } else { 
        printf("Read unexpected signal\n"); 
        } 
     } 
  }</pre><p>L17-L21：将感兴趣的信号加入到sigset_t中；</p>
<p>L24：调用signalfd，把信号集与fd关联起来，第一个参数为-1表示新建一个signalfd，不是-1并且是一个合法的signalfd表示向其添加新的信号。</p>
<p>L29：阻塞等待信号的发生并读取。根据读取的结果可以知道发生了什么信号。<b></b></p>
<h2><b>timerfd涉及的API</b></h2>
<div>
<pre class="crayon-plain-tag">#include &lt;sys/timerfd.h&gt; 
int timerfd_create(int clockid, int flags); 
int timerfd_settime(int fd, int flags, const struct itimerspec *new_value,struct itimerspec *old_value); 
int timerfd_gettime(int fd, struct itimerspec *curr_value);</pre>
</div>
<p>timerfd_create：创建一个timerfd；返回的fd可以进行如下操作：read、select(poll、epoll)、close</p>
<p>timerfd_settime：设置timer的周期，以及起始间隔</p>
<p>timerfd_gettime：获取到期时间。</p><pre class="crayon-plain-tag">//函数参数中数据结构如下： 
struct timespec 
{ 
    time_t tv_sec; /* Seconds */ 
    long tv_nsec; /* Nanoseconds */ 
}; 
  struct itimerspec 
{ 
    struct timespec it_interval; /* Interval for periodic timer */ 
    struct timespec it_value; /* Initial expiration */ 
};</pre><p></p>
<div>
<p>l<b>例子</b></p>
</div>
<p></p><pre class="crayon-plain-tag">#include &lt;sys/timerfd.h&gt; 
  #include &lt;sys/time.h&gt; 
  #include &lt;time.h&gt; 
  #include &lt;unistd.h&gt; 
  #include &lt;stdlib.h&gt; 
  #include &lt;stdio.h&gt; 
  #include &lt;stdint.h&gt; /* Definition of uint64_t */ 
 
  #define handle_error(msg) \ 
  do { perror(msg); exit(EXIT_FAILURE); } while (0) 
 
  void printTime() 
  { 
      struct timeval tv; 
      gettimeofday(&amp;tv, NULL); 
      printf("printTime: current time:%ld.%ld ", tv.tv_sec, tv.tv_usec); 
  } 
 
  int main(int argc, char *argv[]) 
  { 
      struct timespec now; 
      if (clock_gettime(CLOCK_REALTIME, &amp;now) == -1) 
          handle_error("clock_gettime"); 
 
      struct itimerspec new_value; 
      new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]); 
      new_value.it_value.tv_nsec = now.tv_nsec; 
      new_value.it_interval.tv_sec = atoi(argv[2]); 
      new_value.it_interval.tv_nsec = 0; 
 
      int fd = timerfd_create(CLOCK_REALTIME, 0); 
      if (fd == -1) 
      handle_error("timerfd_create"); 
 
      if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &amp;new_value, NULL) == -1) 
          handle_error("timerfd_settime"); 
 
      printTime(); 
      printf("timer started\n"); 
 
      for (uint64_t tot_exp = 0; tot_exp &lt; atoi(argv[3]);) 
      { 
          uint64_t exp; 
          ssize_t s = read(fd, &amp;exp, sizeof(uint64_t)); 
          if (s != sizeof(uint64_t)) 
              handle_error("read"); 
 
          tot_exp += exp; 
          printTime(); 
          printf("read: %llu; total=%llu\n",exp, tot_exp); 
  } 
 
  exit(EXIT_SUCCESS); 
 }</pre><p>代码L25-L29：初始化定时器的参数，初始间隔与定时间隔。</p>
<p>L32：创建定时器fd，CLOCK_REALTIME：真实时间类型，修改时钟会影响定时器；CLOCK_MONOTONIC：相对时间类型，修改时钟不影响定时器。</p>
<p>L35：设置定时器的值。</p>
<p>L44：阻塞等待定时器到期。返回值是未处理的到期次数。比如定时间隔为2秒，但过了10秒才去读取，则读取的值是5。</p>
<p>编译运行：编译时要加rt库(g++ -lrt timerfd.cc -o timerfd)</p>
<p>[root@localhost appTest]# ./timerfd 5 2 10<br />
printTime:  current time:1357391736.146196 timer started<br />
printTime:  current time:1357391741.153430 read: 1; total=1<br />
printTime:  current time:1357391743.146550 read: 1; total=2<br />
printTime:  current time:1357391745.151483 read: 1; total=3<br />
printTime:  current time:1357391747.161155 read: 1; total=4<br />
printTime:  current time:1357391749.153934 read: 1; total=5<br />
printTime:  current time:1357391751.157309 read: 1; total=6<br />
printTime:  current time:1357391753.158384 read: 1; total=7<br />
printTime:  current time:1357391755.150470 read: 1; total=8<br />
printTime:  current time:1357391757.150253 read: 1; total=9<br />
printTime:  current time:1357391759.149954 read: 1; total=10<br />
[root@localhost appTest]#</p>
<p>第一个参数5为第一次定时器到期间隔，第二个参数2为定时器的间隔，第三个参数为定时器到期10次则退出。程序运行(5+2*10)S退出。</p>
<p>详细信息可以：man timerfd_create</p>
<h2><b>eventfd涉及API：</b></h2>
<div>
<pre class="crayon-plain-tag">#include &lt;sys/eventfd.h&gt; 
int eventfd(unsigned int initval, int flags);</pre>
</div>
<p>创建一个eventfd，这是一个计数器相关的fd，计数器不为零是有可读事件发生，read以后计数器清零，write递增计数器；返回的fd可以进行如下操作：read、write、select(poll、epoll)、close。</p>
<p>这个函数会创建一个事件对象 (eventfd object), 用来实现，进程(线程)间的等待/通知(wait/notify) 机制. 内核会为这个对象维护一个64位的计数器(uint64_t)。并且使用第一个参数(initval)初始化这个计数器。调用这个函数就会返回一个新的文件描述符(event object)。2.6.27版本开始可以按位设置第二个参数(flags)。有如下的一些宏可以使用：</p>
<p>l<b>EFD_NONBLOCK</b><b></b></p>
<p>功能同open(2)的O_NONBLOCK，设置对象为非阻塞状态，如果没有设置这个状态的话，read(2)读eventfd,并且计数器的值为0 就一直堵塞在read调用当中，要是设置了这个标志， 就会返回一个 EAGAIN 错误(errno = EAGAIN)。效果也如同 额外调用select(2)达到的效果。</p>
<p>l<b>EFD_CLOEXEC</b><b></b></p>
<p>这个标识被设置的话，调用exec后会自动关闭文件描述符，防止泄漏。如果是2.6.26或之前版本的内核，flags 必须设置为0。<br />
创建这个对象后，可以对其做如下操作：</p>
<p>1) write： 将缓冲区写入的8字节整形值加到内核计数器上。</p>
<p>2) read： 读取8字节值， 并把计数器重设为0. 如果调用read的时候计数器为0， 要是eventfd是阻塞的， read就一直阻塞在这里，否则就得到 一个EAGAIN错误。如果buffer的长度小于8那么read会失败， 错误代码被设置成 EINVAL。</p>
<p>3) poll select epoll</p>
<p>4) close: 当不需要eventfd的时候可以调用close关闭， 当这个对象的所有句柄都被关闭的时候，内核会释放资源。 为什么不是close就直接释放呢， 如果调用fork 创建<br />
进程的时候会复制这个句柄到新的进程，并继承所有的状态。</p>
<p>l<b>例子<br />
</b></p><pre class="crayon-plain-tag">#include &lt;sys/eventfd.h&gt;
 #include &lt;unistd.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdint.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;errno.h&gt;
 #define handle_error(msg) \
    do { perror(msg); exit(1); } while (0)
int main( int argc, char **argv ){
     uint64_t u;
     ssize_t s;5 int j;
     if ( argc &lt; 2 ) {
        fprintf(stderr, "input in command argument");
         exit(1);
     }
 
     int efd;
     if ( (efd = eventfd(0, EFD_NONBLOCK)) == -1 )
             handle_error("eventfd failed");
 
 
     switch (fork()) {
         case 0:
             for( j = 1; j &lt; argc; j ++ ) {
                 printf("Child writing %s to efd\n", argv[j] );
             
                 u = strtoull(argv[j], NULL, 0); /* analogesly atoi */
                 s = write(efd, &amp;u, sizeof(uint64_t));/*append u to counter */
                 if ( s != sizeof(uint64_t) )
                     handle_error("write efd failed");
 
             }
             printf("child completed write loop\n");
 
             exit(0);
         default:
             sleep (2);
             
             printf("parent about to read\n");
             s = read(efd, &amp;u, sizeof(uint64_t));
             if ( s != sizeof(uint64_t) ) {
                 if (errno = EAGAIN) {
                     printf("Parent read value %d\n", s);
                     return 1;
                 }
                 handle_error("parent read failed");
             }
             printf("parent read %d , %llu (0x%llx) from efd\n",
                     s, (unsigned long long)u, (unsigned long long) u);
             exit(0);
 
         case -1:
             handle_error("fork ");
     }
     return 0;
}</pre><p></p>
<div></div>
<p><a href="http://blog.jobbole.com/106933/">Linux 新的API signalfd、timerfd、eventfd使用说明</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/106933/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>一个屌丝程序猿的人生（39）</title>
		<link>http://blog.jobbole.com/106922/</link>
		<comments>http://blog.jobbole.com/106922/#comments</comments>
		<pubDate>Sun, 23 Oct 2016 12:35:51 +0000</pubDate>
		<dc:creator><![CDATA[左潇龙]]></dc:creator>
				<category><![CDATA[趣文小说]]></category>
		<category><![CDATA[屌程]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=106922</guid>
		<description><![CDATA[<p>有史晓玲这么一位颜值不错的妹子常伴左右，换作一般人还真的很难静下心来学习，但是林萧却很清楚，在眼前的情况下，撩妹和学习到底孰轻孰重。</p><p><a href="http://blog.jobbole.com/106922/">一个屌丝程序猿的人生（39）</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<div id="cnblogs_post_body">
<p>本系列：<a title="一个屌丝程序猿的人生（1）" href="http://blog.jobbole.com/100447/" target="_blank">第 1 篇</a> 、<a title="一个屌丝程序猿的人生（2）" href="http://blog.jobbole.com/100505/" target="_blank">第 2 篇</a>、<a title="一个屌丝程序猿的人生（3）" href="http://blog.jobbole.com/100588/" target="_blank">第 3 篇</a>、<a title="一个屌丝程序猿的人生（4）" href="http://blog.jobbole.com/100687/" target="_blank">（4）</a>、<a title="一个屌丝程序猿的人生（5）" href="http://blog.jobbole.com/100688/" target="_blank">（5）</a>、<a title="一个屌丝程序猿的人生（6）" href="http://blog.jobbole.com/100739/" target="_blank">（6）</a>、<a title="一个屌丝程序猿的人生（7）" href="http://blog.jobbole.com/100860/" target="_blank">（7）</a>、<a title="一个屌丝程序猿的人生（8）" href="http://blog.jobbole.com/100974/" target="_blank">（8）</a>、<a href="http://blog.jobbole.com/101087/" target="_blank">（9）</a>、<a href="http://blog.jobbole.com/101142/" target="_blank">10）</a>、<a class="archive-title" title="一个屌丝程序猿的人生（11）" href="http://blog.jobbole.com/101148/" target="_blank">（11）</a>、<a href="http://blog.jobbole.com/101196/" target="_blank">（12）</a>、<a href="http://blog.jobbole.com/101252/" target="_blank">（13）</a>、<a href="http://blog.jobbole.com/101298/" target="_blank">（14）</a>、<a href="http://blog.jobbole.com/101323/" target="_blank">（15）</a>、<a href="http://blog.jobbole.com/101435/" target="_blank">（16）</a>、<a href="http://blog.jobbole.com/101477/" target="_blank">（17）</a>、<a href="http://blog.jobbole.com/101629/" target="_blank">（18）</a>、<a href="http://blog.jobbole.com/101679/" target="_blank">（19）</a>、<a href="http://blog.jobbole.com/101828/" target="_blank">（20）</a>、<a href="http://blog.jobbole.com/101852/" target="_blank">（21）</a>、<a class="archive-title" title="一个屌丝程序猿的人生（22）" href="http://blog.jobbole.com/102023/" target="_blank">（22）</a>、<a href="http://blog.jobbole.com/102083/" target="_blank">（23）</a>、<a href="http://blog.jobbole.com/102210/" target="_blank">（24）</a>、<a href="http://blog.jobbole.com/102385/" target="_blank">（25）</a>、<a href="http://blog.jobbole.com/102501/" target="_blank">（26）</a>、<a href="http://blog.jobbole.com/102708/" target="_blank">（27）</a>、<a href="http://blog.jobbole.com/102790/" target="_blank">（28）</a>、<a href="http://blog.jobbole.com/102967/" target="_blank">（29）</a>、<a href="http://blog.jobbole.com/103329/" target="_blank">（30）</a>、<a href="http://blog.jobbole.com/103526/" target="_blank">（31）</a>、<a href="http://blog.jobbole.com/103839/" target="_blank">（32）</a>、<a href="http://blog.jobbole.com/104229/" target="_blank">（33）</a>、<a href="http://blog.jobbole.com/104401/" target="_blank">（34）</a>、<a href="http://blog.jobbole.com/105045/" target="_blank">（35）</a>、<a href="http://blog.jobbole.com/105358/" target="_blank">（36）</a>、<a href="http://blog.jobbole.com/105430/" target="_blank">（37）</a>、<a href="http://blog.jobbole.com/106454/" target="_blank">（38）</a></p>
<hr />
<p>有史晓玲这么一位颜值不错的妹子常伴左右，换作一般人还真的很难静下心来学习，但是林萧却很清楚，在眼前的情况下，撩妹和学习到底孰轻孰重。</p>
<p>更何况，这妹子可是怀了张亮的孩子的，就算是要撩妹，林萧也还没到饥不择食的地步，拿自己兄弟的妹子下手。</p>
<p>这事儿特么不地道啊！</p>
<p>于是，心无旁鹭的林萧，在结束了Java基础的学习之后，立即便开始了接下来的视频学习。</p>
<p>&#8230;&#8230;</p>
<p>紧接着Java基础的一章，是Java高级特性。</p>
<p>不知为何，程序猿总会对这些听起来很牛逼的词汇感兴趣，因此，一看到“高级特性”四个字，林萧立马就来了精神。</p>
<p>然而事实上，真正牛逼的东西，往往不是那么好理解的。至少对于一个初入Java领域的菜鸟来说，“高级特性”这四个字还是太过深奥了一些。</p>
<p>就说“高级特性”中最开始的内容吧，面向对象的三个重要特性，继承、封装以及多态。</p>
<p>其中继承其实已经是最好理解的一个了，原因是继承在现实中的例子实在是太多了，最典型的就是父子之间的关系。</p>
<p>儿子会继承老爸身上某一部分的特征，并且还会拥有老爸身上所没有的一些特点。这正是诠释着，子类可以继承父类的属性和方法，并且通常还会拥有父类所没有的一些属性和方法。</p>
<p>与此同时，儿子虽然可以继承老爸的一些特征，但也并不是所有特征都可以继承的。因此，这也正是诠释着，子类只能继承父类部分的属性和方法，一些隐藏比较深的，例如被private所修饰的，子类也是继承不了的。</p>
<p>知道继承的以上两点，对于一个新人来说，就基本上足够了。至于一些有关继承比较高级的用法，例如模板方法模式这种的，就只能在以后的路上，慢慢研究去了。</p>
<p>封装相较于继承，会比较难理解一些。不过对于很抽象很难理解的知识，林萧有自己的办法，那就是找相似的事物。</p>
<p>因为林萧相信，世间万物都是相通的，任何一个知识点，你总能在其它领域找到相似的。</p>
<p>就说谈恋爱这回事吧，都说没有最好的，只有最合适的，这句话，其实也同样可以适用于找工作，这就是一个最简单的道理相通的例子。</p>
<p>知道了这一点之后，如何找到一个合适的例子，就比较关键了。</p>
<p>关于封装的现实例子，其实说起来还是蛮多的。就说叫外卖这件事吧，其实卖家就充分体现了封装的思想。</p>
<p>那么卖家到底封装了哪些东西？</p>
<p>很显然，大致包括了买菜、洗菜、做饭、送饭等等一系列的动作，而你只需要付钱给外卖员，就可以吃到香喷喷的饭菜。你不需要知道如何买菜，如何做饭等等这些琐碎的事情，你要做的就一件事，就是掏钱！</p>
<p>这就是现实中封装的思想，也就是所谓的一站式服务。</p>
<p>对应到编程世界，其实也是一样的，一个类要尽可能把自己的服务细节隐藏起来，不对外部暴露，让外部的类只需要“付钱”，就可以方便的调用服务即可。</p>
<p>隐藏细节，这其实就是封装的核心思想了。</p>
<p>三大特性中，继承和封装都说完了，还剩下最后一个特性，也是最难理解的一个。</p>
<p>多态在很多人刚接触Java时，都难免会觉得懵逼，林萧也不例外。尽管他一直在试图理解“不同的类型有不同的表现”这句话，但其实他在当时，始终都没有理解到多态的本质。</p>
<p>多态的本质其实用一句话就可以概括，就是“编译时和运行时才决定对象的行为”，俗称为静态分派和动态分派。</p>
<p>很多人第一次看到这两个词的时候，应该比看到多态更加懵逼，但其实沉下心来去想想，这两个词其实非常好理解。</p>
<p>不过理解的前提是，你要非常清楚一个Java程序从编写到运行的过程，简单的说，这个过程就是编译和执行。</p>
<p>而静态分派和动态分派的本质就是，静态分派是编译期间就可以决定的，而动态分派则是执行期间才可以决定的。</p>
<p>要理解编译期和执行期其实也非常好理解，你可以把计算机看做是一个英国人，而你是一个中国人，程序就是你写的一篇文章。</p>
<p>那么计算机要想运行你的程序，也就相当于英国人要想读你的文章。</p>
<p>那就首先得有人把你的文章翻译成英文，这个过程就相当于编译的过程。这个负责翻译的人，在现实里就叫翻译员，而在程序世界里，就是编译器。</p>
<p>当文章被翻译成英文以后，英国人就开始阅读你的文章，也就相当于计算机开始运行你的程序。</p>
<p>而对于Java程序来说，编译器其实就是javac，而所谓的计算机，其实就是JVM。</p>
<p>理解这个最基本的编译和执行的过程，静态分派和动态分派就很好理解了。而理解了静态分派和动态分派，多态就非常好理解了。</p>
<p>当然了，这些知识，对于初学Java的林萧来说，当然是不太可能彻底理解的，不过这其实并无大碍，学习本身就是一个循序渐进的过程。</p>
<p>&#8230;&#8230;</p>
<p>说起来，林萧也算是够拼命的，自从开始培训以后，几乎就变成了足不出户的骨灰级宅男，与当初在家里玩游戏的时候，简直是如出一撤。</p>
<p>一天下来，除了上厕所和拿外卖以外，林萧几乎可以做到坐在椅子上一动不动。这种惊人的毅力和懒的程度，如果不是以前玩游戏早已经习惯了的话，说不定林萧还真坚持不下来。</p>
<p>但是，这种生活虽然看起来挺苦逼的，林萧却非常乐在其中。而且，游戏所带来的快感，与知识所带来的快感相比，始终缺少了一种充实感。</p>
<p>这种充实感，可以帮你驱散孤独，也会让你有种，未来掌握在自己手里的安全感。</p>
<p>此时此刻，林萧心中多少有些明白了，为什么有人说，成功的男人要学会享受孤独。因为享受孤独的过程，其实就是你充实自己的过程。</p>
<p>然而，就在林萧尽情享受孤独，疯狂得充实自己的时候，一个故人却再次打断了这种疯狂而又宁静的生活。</p>
<p>她，来了。</p>
<p>&nbsp;</p>
</div>
<p><a href="http://blog.jobbole.com/106922/">一个屌丝程序猿的人生（39）</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/106922/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>C++ 内存分配(new，operator new)详解</title>
		<link>http://blog.jobbole.com/106923/</link>
		<comments>http://blog.jobbole.com/106923/#respond</comments>
		<pubDate>Sun, 23 Oct 2016 12:11:55 +0000</pubDate>
		<dc:creator><![CDATA[中二饼]]></dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[C语言]]></category>
		<category><![CDATA[new]]></category>
		<category><![CDATA[operator new]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=106923</guid>
		<description><![CDATA[<p>本文主要讲述C++ new运算符和operator new, placement new之间的种种关联，new的底层实现，以及operator new的重载和一些在内存池，STL中的应用。</p><p><a href="http://blog.jobbole.com/106923/">C++ 内存分配(new，operator new)详解</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p>本文主要讲述C++ new运算符和operator new, placement new之间的种种关联，new的底层实现，以及operator new的重载和一些在内存池，STL中的应用。</p>
<h3>一 new 运算符和 operator new()：</h3>
<p>new：指我们在C++里通常用到的运算符，比如A* a = new A;  对于new来说，有new和::new之分，前者位于std</p>
<p>operator new()：指对new的重载形式，它是一个函数，并不是运算符。对于operator new来说，分为全局重载和类重载，全局重载是void* ::operator new(size_t size)，在类中重载形式 void* A::operator new(size_t size)。还要注意的是这里的operator new()完成的操作一般只是分配内存，事实上系统默认的全局::operator new(size_t size)也只是调用malloc分配内存，并且返回一个void*指针。而构造函数的调用(如果需要)是在new运算符中完成的。</p>
<p>先简单解释一下new和operator new之间的关系：</p>
<p>关于这两者的关系，我找到一段比较经典的描述（来自于www.cplusplus.com 见参考文献）：</p>
<blockquote><p><code>operator new</code> can be called explicitly as a regular function, but in C++, <code>new</code> is an operator with a very specific behavior: An expression with the <code>new</code> operator, first calls function <code>operator new</code> (i.e., this function) with the size of its type specifier as first argument, and if this is successful, it then automatically initializes or constructs the object (if needed). Finally, the expression evaluates as a pointer to the appropriate type.</p></blockquote>
<p>比如我们写如下代码：</p><pre class="crayon-plain-tag">A* a = new A;</pre><p>我们知道这里分为两步：1.分配内存，2.调用A()构造对象。事实上，分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，如果没有重载，就调用::operator new(size_t )，全局new操作符由C++默认提供。因此前面的两步也就是：1.调用operator new 2.调用构造函数。这里再一次提出来是因为后面关于这两步会有一些变形，在关于placement new那里会讲到。</p>
<p>先举个简单例子</p><pre class="crayon-plain-tag">//平台：Visual Stdio 2008  
#include&lt;iostream&gt;  
class A  
{  
public:  
     A()  
     {  
          std::cout&lt;&lt;"call A constructor"&lt;&lt;std::endl;  
     }  
  
     ~A()  
     {  
          std::cout&lt;&lt;"call A destructor"&lt;&lt;std::endl;  
     }  
}  
int _tmain(int argc, _TCHAR* argv[])  
{  
  
     A* a = new A;  
     delete a;  
  
     system("pause");  
     return 0;  
}</pre><p>下面我们跟踪一下A反汇编代码，由于Debug版本反汇编跳转太多，因此此处通过Release版本在A* a = new A;处设断点反汇编：<br />
在Release版本中，构造函数和析构函数都是直接展开的。</p><pre class="crayon-plain-tag">A* a = new A;  
01301022  push        1    ;不含数据成员的类占用一字节空间，此处压入sizeof(A)  
01301024  call        operator new (13013C2h) ;调用operator new(size_t size)  
01301029  mov         esi,eax ;返回值保存到esi  
0130102B  add         esp,4 ;平衡栈  
0130102E  mov         dword ptr [esp+8],esi ;  
01301032  mov         dword ptr [esp+14h],0   
0130103A  test        esi,esi ;在operator new之后，检查其返回值，如果为空(分配失败)，则不调用A()构造函数  
0130103C  je          wmain+62h (1301062h) ;为空 跳过构造函数部分  
0130103E  mov         eax,dword ptr [__imp_std::endl (1302038h)] ;构造函数内部，输出字符串  
01301043  mov         ecx,dword ptr [__imp_std::cout (1302050h)]   
01301049  push        eax    
0130104A  push        offset string "call A constructor" (1302134h)   
0130104F  push        ecx    
01301050  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (13011F0h)   
01301055  add         esp,8   
01301058  mov         ecx,eax   
0130105A  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (1302040h)]   
01301060  jmp         wmain+64h (1301064h) ;构造完成，跳过下一句  
01301062  xor         esi,esi ;将esi置空，这里的esi即为new A的返回值  
01301064  mov         dword ptr [esp+14h],0FFFFFFFFh   
    delete a;  
0130106C  test        esi,esi ;检查a是否为空  
0130106E  je          wmain+9Bh (130109Bh) ;如果为空，跳过析构函数和operator delete  
01301070  mov         edx,dword ptr [__imp_std::endl (1302038h)] ;析构函数 输出字符串  
01301076  mov         eax,dword ptr [__imp_std::cout (1302050h)]   
0130107B  push        edx    
0130107C  push        offset string "call A destructor" (1302148h)   
01301081  push        eax    
01301082  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (13011F0h)   
01301087  add         esp,8   
0130108A  mov         ecx,eax   
0130108C  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (1302040h)]   
01301092  push        esi  ;压入a   
01301093  call        operator delete (13013BCh) ;调用operator delete   
01301098  add         esp,4   
通过反汇编可以看出A* = new A包含了operator new(sizeof(A))和A()两个步骤(当然，最后还要将值返回到a)  
         delete a包含了~A()和operator delete(a)两个步骤。</pre><p></p>
<h3>二 operator new 的三种形式：</h3>
<p>operator new有三种形式：</p>
<p>throwing (1)</p><pre class="crayon-plain-tag">void* operator new (std::size_t size) throw (std::bad_alloc);</pre><p>nothrow (2)</p><pre class="crayon-plain-tag">void* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) throw();</pre><p>placement (3)</p><pre class="crayon-plain-tag">void* operator new (std::size_t size, void* ptr) throw();</pre><p>(1)(2)的区别仅是是否抛出异常，当分配失败时，前者会抛出bad_alloc异常，后者返回null，不会抛出异常。它们都分配一个固定大小的连续内存。</p>
<p>用法示例：</p><pre class="crayon-plain-tag">A* a = new A; //调用throwing(1)
A* a = new(std::nothrow) A; //调用nothrow(2)</pre><p>（3）是placement new，它也是对operator new的一个重载，定义于中，它多接收一个ptr参数，但它只是简单地返回ptr。</p>
<p>其在new.h下的源代码如下：</p><pre class="crayon-plain-tag">#define __PLACEMENT_NEW_INLINE  
inline void *__cdecl operator new(size_t, void *_P)  
        {return (_P); }  
#if     _MSC_VER &gt;= 1200  
inline void __cdecl operator delete(void *, void *)  
    {return; }  
#endif  
#endif</pre><p>那么它究竟有什么用呢？事实上，它可以实现在ptr所指地址上构建一个对象(通过调用其构造函数)，这在内存池技术上有广泛应用。<br />
它的调用形式为：</p><pre class="crayon-plain-tag">new(p) A(); //也可用A(5)等有参构造函数。</pre><p>前面说到，new运算符都会调用operator new，而这里的operator new(size_t, void*)并没有什么作用，真正起作用的是new运算符的第二个步骤：在p处调用A构造函数。这里的p可以是动态分配的内存，也可以是栈中缓冲，如char buf[100]; new(buf) A();</p>
<p>我们仍然可以通过一个例子来验证：</p><pre class="crayon-plain-tag">#include &lt;iostream&gt;  
class A  
{  
public:  
    A()  
    {  
        std::cout&lt;&lt;"call A constructor"&lt;&lt;std::endl;  
    }  
  
    ~A()  
    {  
        std::cout&lt;&lt;"call A destructor"&lt;&lt;std::endl;  
    }  
};  
int _tmain(int argc, _TCHAR* argv[])  
{  
  
    A* p = (A*)::operator new(sizeof(A)); //分配  
  
    new(p) A(); //构造  
      
    p-&gt;~A(); //析构  
  
    ::operator delete(p); //释放  
  
    system("pause");  
    return 0;  
}</pre><p><img class="aligncenter" src="http://jbcdn2.b0.upaiyun.com/2016/10/ef77e7f5f64534f618a5a12ac91891ca.jpeg" alt="" /><br />
上面的代码将对象的分配，构造，析构和释放分离开来，这也是new和delete运算符两句就能完成的操作。</p>
<p>先直接运行可以看到程序输出：</p>
<p>再分别注释掉new(a) A();和a-&gt;~A();两句，可以看到对应的构造和析构函数将不会被调用。</p>
<p>然后查看反汇编：</p>
<p>平台: Visual Studio 2008 Debug版</p><pre class="crayon-plain-tag">A* a = (A*)::operator new(sizeof(A)); //分配  
00F9151D  push        1      
00F9151F  call        operator new (0F91208h) ;调用::operator new(size_t size)也就是throwing(1)版本  
00F91524  add         esp,4   
00F91527  mov         dword ptr [ebp-14h],eax ;返回地址放入[ebp-14h] 即为p  
  
    new(a) A(); //构造  
00F9152A  mov         eax,dword ptr [ebp-14h]   
00F9152D  push        eax    
00F9152E  push        1    ;压入p  
00F91530  call        operator new (0F91280h);调用operator new(size_t, void* p)即placement(3)版本 只是简单返回p  
00F91535  add         esp,8   
00F91538  mov         dword ptr [ebp-0E0h],eax ;将p放入[ebp-0E0h]  
00F9153E  mov         dword ptr [ebp-4],0   
00F91545  cmp         dword ptr [ebp-0E0h],0   ;判断p是否为空  
00F9154C  je          wmain+81h (0F91561h)     ;如果为空 跳过构造函数  
00F9154E  mov         ecx,dword ptr [ebp-0E0h] ;取出p到ecx  
00F91554  call        A::A (0F91285h)          ;调用构造函数 根据_thiscall调用约定 this指针通过ecx寄存器传递  
00F91559  mov         dword ptr [ebp-0F4h],eax ;将返回值(this指针)放入[ebp-0F4h]中  
00F9155F  jmp         wmain+8Bh (0F9156Bh)     ;跳过下一句  
00F91561  mov         dword ptr [ebp-0F4h],0   ;将[ebp-0F4h]置空 当前面判断p为空时执行此语句  
00F9156B  mov         ecx,dword ptr [ebp-0F4h] ;[ebp-0F4h]为最终构造完成后的this指针(或者为空) 放入ecx  
00F91571  mov         dword ptr [ebp-0ECh],ecx ;又将this放入[ebp-0ECh] 这些都是调试所用  
00F91577  mov         dword ptr [ebp-4],0FFFFFFFFh   
      
    a-&gt;~A(); //析构  
00F9157E  push        0      
00F91580  mov         ecx,dword ptr [ebp-14h] ;从[ebp-14h]中取出p  
00F91583  call        A::`scalar deleting destructor' (0F91041h) ;调用析构函数(跟踪进去比较复杂 如果在Release下，构造析构函数都是直接展开的)  
  
    ::operator delete(a); //释放  
00F91588  mov         eax,dword ptr [ebp-14h]   ;将p放入eax  
00F9158B  push        eax           ;压入p  
00F9158C  call        operator delete (0F910B9h);调用operator delete(void* )  
00F91591  add         esp,4 &lt;/span&gt;</pre><p>从反汇编中可以看出，其实operator new调用了两次，只不过每一次调用不同的重载函数，并且placement new的主要作用只是将p放入ecx，并且调用其构造函数。</p>
<p>事实上，在指定地址上构造对象还有另一种方法，即手动调用构造函数：p-&gt;A::A(); 这里要加上A::作用域，否则编译器会报错：error C2273: “函数样式转换”: 位于“-&gt;”运算符右边时非法</p>
<p>用p-&gt;A::A();替换掉new(p) A();仍然能达到同样的效果，反汇编：</p><pre class="crayon-plain-tag">A* a = (A*)::operator new(sizeof(A)); //分配  
010614FE  push        1      
01061500  call        operator new (1061208h)   
01061505  add         esp,4   
01061508  mov         dword ptr [a],eax   
  
    //new(a) A();   //构造  
    a-&gt;A::A();  
0106150B  mov         ecx,dword ptr [a]   
0106150E  call        operator new (1061285h)   
  
    a-&gt;~A(); //析构  
01061513  push        0      
01061515  mov         ecx,dword ptr [a]   
01061518  call        A::`scalar deleting destructor' (1061041h)   
  
    ::operator delete(a); //释放  
0106151D  mov         eax,dword ptr [a]   
01061520  push        eax    
01061521  call        operator delete (10610B9h)   
01061526  add         esp,4</pre><p>比之前的方法更加简洁高效(不需要调用placement new)。不知道手动调用构造函数是否有违C++标准或有什么隐晦，我在其他很多有名的内存池(包括SGI STL alloc)实现上看到都是用的placement new，而不是手动调用构造函数。</p>
<h3>三 operator new 重载：</h3>
<p>前面简单提到过 A* p = new A；所发生的事情：先调用operator new，如果类A重载了operator new，那么就使用该重载版本，否则使用全局版本::operatro new(size_t size)。那么类中可以重载operator new的哪些版本？全局operator new可以重载吗？全局和类中重载分别会在什么时机调用？</p>
<h4>1.在类中重载 operator new</h4>
<p>上面提到的throwing(1)和nothrow(2)的operator new是可以被重载的，比如：</p><pre class="crayon-plain-tag">#include &lt;iostream&gt;  
class A  
{  
public:  
    A()  
    {  
        std::cout&lt;&lt;"call A constructor"&lt;&lt;std::endl;  
    }  
  
    ~A()  
    {  
        std::cout&lt;&lt;"call A destructor"&lt;&lt;std::endl;  
    }  
    void* operator new(size_t size)  
    {  
        std::cout&lt;&lt;"call A::operator new"&lt;&lt;std::endl;  
        return malloc(size);  
    }  
  
    void* operator new(size_t size, const std::nothrow_t&amp; nothrow_value)  
    {  
        std::cout&lt;&lt;"call A::operator new nothrow"&lt;&lt;std::endl;  
        return malloc(size);  
    }  
};  
int _tmain(int argc, _TCHAR* argv[])  
{  
    A* p1 = new A;  
    delete p1;  
  
    A* p2 = new(std::nothrow) A;  
    delete p2;  
  
    system("pause");  
    return 0;  
}</pre><p><img alt="" /><br />
<img class="aligncenter" src="http://img.blog.csdn.net/20130710083057671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1VEQUlKVU4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /><br />
如果类A中没有对operator new的重载，那么new A和new(std::nothrow) A;都将会使用全局operator new(size_t size)。可将A中两个operator new注释掉，并且在A外添加一个全局operator new重载：</p><pre class="crayon-plain-tag">void* ::operator new(size_t size)  
{  
    std::cout&lt;&lt;"call global operator new"&lt;&lt;std::endl;  
    return malloc(size);  
}</pre><p>程序输出：<br />
<img class="aligncenter" src="http://jbcdn2.b0.upaiyun.com/2016/10/d91568999755f71b5f2e05c5504f15b5.jpeg" alt="" /><br />
注意，这里的重载遵循作用域覆盖原则，即在里向外寻找operator new的重载时，只要找到operator new()函数就不再向外查找，如果参数符合则通过，如果参数不符合则报错，而不管全局是否还有相匹配的函数原型。比如如果这里只将A中operator new(size_t, const std::nothrow_t&amp;)删除掉，就会报错：</p>
<p>error C2660: “A::operator new”: 函数不接受 2 个参数。</p>
<p>至于placement new，它本身就是operator new的一个重载，不需也尽量不要对它进行改写，因为它一般是搭配 new(p) A(); 工作的，它的职责只需简单返回指针。</p>
<p>对operator new的重载还可以添加自定义参数，如在类A中添加</p><pre class="crayon-plain-tag">void* operator new(size_t size, int x, int y, int z)  
{  
    std::cout&lt;&lt;"X="&lt;&lt;x&lt;&lt;"  Y="&lt;&lt;y&lt;&lt;" Z="&lt;&lt;z&lt;&lt;std::endl;  
    return malloc(size);  
}</pre><p>这种重载看起来没有什么大作用，因为它operator new需要完成的任务只是分配内存，但是通过对这类重载的巧妙应用，可以让它在动态分配内存调试和检测中大展身手。这将在后面operator new重载运用技巧中，展现。</p>
<h4>2.重载全局 operator new</h4>
<p>全局operator new的重载和在类中重载并无太大区别，当new A;时，如果类A中没有重载operator new，那么将调用全局operator new函数，如果没有重载全局operator new，最后会调用默认的全局operator new。</p>
<h4>3.类中operator new和全局 operator new 的调用时机</h4>
<p>前面已经提到了在new时的调用顺序，但是这里提出来的原因是还存在一个全局的new运算符，也就是::new，这个运算符会直接调用全局operator new，并且也会调用构造函数。这可能让人很犯迷糊，只做了解即可。这里提到的调用时机都是指通过new运算符调用，没有讨论其他情况，比如主动调用。</p>
<h3>四 operator new运用技巧和一些实例探索</h3>
<h4>1.operator new 重载运用于调试：</h4>
<p>前面提到如何operator new的重载是可以有自定义参数的，那么我们如何利用自定义参数获取更多的信息呢，这里一个很有用的做法就是给operator new添加两个参数:char* file, int line,这两个参数记录new运算符的位置，然后再在new时将文件名和行号传入，这样我们就能在分配内存失败时给出提示：输出文件名和行号。</p>
<p>那么如何获取当前语句所在文件名和行号呢，windows提供两个宏：__FILE__和__LINE__。利用它们可以直接获取到文件名和行号，也就是 new(__FILE__, __LINE__) 由于这些都是不变的，因此可以再定义一个宏：#define new new(__FILE__, __LINE__)。这样我们就只需要定义这个宏，然后重载operator new即可。</p>
<p>源代码如下，这里只是简单输出new的文件名和行号。</p><pre class="crayon-plain-tag">//A.h  
class A  
{  
public:  
    A()  
    {  
        std::cout&lt;&lt;"call A constructor"&lt;&lt;std::endl;  
    }  
  
    ~A()  
    {  
        std::cout&lt;&lt;"call A destructor"&lt;&lt;std::endl;  
    }  
  
    void* operator new(size_t size, const char* file, int line)  
    {  
        std::cout&lt;&lt;"call A::operator new on file:"&lt;&lt;file&lt;&lt;"  line:"&lt;&lt;line&lt;&lt;std::endl;  
        return malloc(size);  
        return NULL;  
    }  
  
};  
//Test.cpp  
#include &lt;iostream&gt;  
#include "A.h"  
#define new new(__FILE__, __LINE__)  
  
int _tmain(int argc, _TCHAR* argv[])  
{  
    A* p1 = new A;  
    delete p1;  
  
    A* p2 = new A;  
    delete p2;  
  
    system("pause");  
    return 0;  
}</pre><p>输出：<br />
<img class="aligncenter" src="http://jbcdn2.b0.upaiyun.com/2016/10/33ae7d127f8ac42da751f10d966fa598.jpeg" alt="" /><br />
<img alt="" /><br />
注意：需要将类的声明实现与new的使用隔离开来。并且将类头文件放在宏定义之前。否则在类A中的operator new重载中的new会被宏替换，整个函数就变成了： void* operator new(__FILE__, __LINE__)(size_t size, char* file, int line)<br />
编译器自然会报错。</p>
<h4>2.内存池优化</h4>
<p>operator new的另一个大用处就是内存池优化，内存池的一个常见策略就是分配一次性分配一块大的内存作为内存池(buffer或pool)，然后重复利用该内存块，每次分配都从内存池中取出，释放则将内存块放回内存池。在我们客户端调用的是new运算符，我们可以改写operator new函数，让它从内存池中取出(当内存池不够时，再从系统堆中一次性分配一块大的)，至于构造和析构则在取出的内存上进行，然后再重载operator delete，它将内存块放回内存池。关于内存池和operator new在参考文献中有一篇很好的文章。这里就不累述了。</p>
<h4>3.STL中的 new</h4>
<p>在SGI STL源码中,defalloc.h和stl_construct.h中提供了最简单的空间配置器(allocator)封装，见《STL源码剖析》P48。它将对象的空间分配和构造分离开来，虽然在defalloc.h中仅仅是对::operator new和::operator delete的一层封装，但是它仍然给STL容器提供了更加灵活的接口</p>
<p>SGI STL真正使用的并不是defalloc.h中的分配器，而是stl_alloc.h中的SGI精心打造的&#8221;双层级配置器&#8221;，它将内存池技术演绎得淋漓尽致，值得细细琢磨。顺便提一下，在stl_alloc.h中并没有使用::operator new/delete 而直接使用malloc和free。具体缘由均可参见《STL源码剖析》。</p>
<h3>五 delete 的使用</h3>
<p>delete的使用基本和new一致，包括operator delete的重载方式这些都相似，只不过它的参数是void*，返回值为void。但是有一点需要注意，operator delete的自定义参数重载并不能手动调用。比如</p><pre class="crayon-plain-tag">void* operator new(size_t size, int x)  
{  
    cout&lt;&lt;" x = "&lt;&lt;x&lt;&lt;endl;  
    return malloc(size);      
}  
void operator delete(void* p, int x)  
{  
    cout&lt;&lt;" x = "&lt;&lt;x&lt;&lt;endl;  
    free(p);  
}</pre><p>如下调用是无法通过的：</p><pre class="crayon-plain-tag">A* p = new(3) A;//Ok
delete(3) p;//error C2541: “delete”: 不能删除不是指针的对象</pre><p>那么重载operator delete有什么作用？如何调用？事实上以上自定义参数operator delete 只在一种情况下被调用：当new运算符抛出异常时。</p>
<p>可以这样理解，只有在new运算符中，编译器才知道你调用的operator new形式，然后它会调用对应的operator delete。一旦出了new运算符，编译器对于你自定义的new将一无所知，因此它只会按照你指定的delete运算符形式来调用operator delete，而至于为什么不能指定调用自定义delete(也就是只能老老实实delete p)，这个就不知道了。</p>
<p>细心观察的话，上面operator new用于调试的例子代码中，由于我们没有给出operator new对应的operator delete。在VS2008下会有如下警告：</p>
<p>warning C4291: “void *A::operator new(size_t,const char *,int)”: 未找到匹配的删除运算符；如果初始化引发异常，则不会释放内存</p>
<h3>六 关于 new 和内存分配的其他</h3>
<h4> 1.set_new_handler</h4>
<p>还有一些零散的东西没有介绍到，比如set_new_handler可以在malloc(需要调用set_new_mode(1))或operator new内存分配失败时指定一个入口函数new_handler，这个函数完成自定义处理(继续尝试分配，抛出异常，或终止程序)，如果new_handler返回，那么系统将继续尝试分配内存，如果失败，将继续重复调用它，直到内存分配完毕或new_handler不再返回(抛出异常，终止)。下面这段程序完成这个测试：</p><pre class="crayon-plain-tag">#include &lt;iostream&gt;  
#include &lt;new.h&gt;// 使用_set_new_mode和set_new_handler  
void nomem_handler()  
{  
    std::cout&lt;&lt;"call nomem_handler"&lt;&lt;std::endl;  
}  
int main()  
{  
    _set_new_mode(1);  //使new_handler有效  
    set_new_handler(nomem_handler);//指定入口函数 函数原型void f();  
    std::cout&lt;&lt;"try to alloc 2GB memory...."&lt;&lt;std::endl;  
    char* a = (char*)malloc(2*1024*1024*1024);  
    if(a)  
        std::cout&lt;&lt;"ok...I got it"&lt;&lt;std::endl;  
    free(a);  
    system("pause");  
}</pre><p>程序运行后会一直输出call nomem_handler 因为函数里面只是简单输出，返回，系统尝试分配失败后，调用nomem_handler函数，由于该函数并没有起到实际作用(让可分配内存增大)，因此返回后系统再次尝试分配失败，再调用nomem_handler，循环下去。</p>
<p>在SGI STL中的也有个仿new_handler函数:oom_malloc</p>
<h4>2.new 分配数组</h4>
<p>A* p = new A[3];中，会直接调用全局的operator new[](size_t size)，而不管A中是否有operator new[]的重载。而delete[]p却会优先调用A::operator delete[](void*)(如果A中有重载)。另外还要注意的是，在operator new[](size_t size)中传入的并不是sizeof(A)*3。而要在对象数组的大小上加上一个额外数据，用于编译器区分对象数组指针和对象指针以及对象数组大小。在VS2008下这个额外数据占4个字节，一个int大小。测试代码如下</p><pre class="crayon-plain-tag">//A.h  
class A  
{  
public:  
    A()  
    {  
        std::cout&lt;&lt;"call A constructor"&lt;&lt;std::endl;  
    }  
  
    ~A()  
    {  
        std::cout&lt;&lt;"call A destructor"&lt;&lt;std::endl;  
    }  
  
    void* operator new(size_t size)  
    {  
        std::cout&lt;&lt;"call A::operator new[] size:"&lt;&lt;size&lt;&lt;std::endl;  
        return malloc(size);  
    }  
    void operator delete[](void* p)  
    {  
        std::cout&lt;&lt;"call A::operator delete[]"&lt;&lt;std::endl;  
        free(p);  
    }   
    void operator delete(void* p)  
    {  
        free(p);  
    }   
};</pre><p></p><pre class="crayon-plain-tag">//Test.cpp  
#include &lt;iostream&gt;  
#include "A.h"  
  
void* operator new[](size_t size)  
{  
    std::cout&lt;&lt;"call global new[] size: "&lt;&lt;size&lt;&lt;std::endl;  
    return malloc(size);  
}  
  
void operator delete[](void* p)  
{  
    std::cout&lt;&lt;"call global delete[] "&lt;&lt;std::endl;  
}  
int _tmain(int argc, _TCHAR* argv[])  
{  
    std::cout&lt;&lt;"sizeof A "&lt;&lt;sizeof(A)&lt;&lt;std::endl;  
    A* p1 = new A[3];  
    delete []p1;  
   
    system("pause");  
    return 0;  
}</pre><p>输出：<br />
<img class="aligncenter" src="http://jbcdn2.b0.upaiyun.com/2016/10/9c7b616ac50fe93fd4ed003dc0ec506a.jpeg" alt="" /></p>
<p><img alt="" /><br />
简单跟踪了一下：</p>
<p>operator new[]返回的是0x005b668 而最后new运算符返回给p的是0x005b66c。也就是说p就是数组的起始地址，这样程序看到的内存就是线性的，不包括前面的额外数据。<br />
<img alt="" /><br />
在内存中，可以看到前面的四个字节额外数据是0x00000003 也就是3，代表数组元素个数。后面三个cd是堆在Debug中的默认值(中文的cdcd就是&#8221;屯&#8221;，栈的初始值为cc，0xcccc中文&#8221;烫&#8221;)。再后面的0xfdfdfdfd应该是堆块的结束标志，前面我有博客专门跟踪过。<br />
<img alt="" /><br />
注：其实在malloc源码中也有内存池的运用，而且也比较复杂。最近在参考dlmalloc版本和STL空间适配器，真没有想到一个内存分配能涉及这么多的东西。</p>
<p><a href="http://blog.jobbole.com/106923/">C++ 内存分配(new，operator new)详解</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/106923/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>制作你的第一个 Atom 文本编辑器插件</title>
		<link>http://blog.jobbole.com/106919/</link>
		<comments>http://blog.jobbole.com/106919/#respond</comments>
		<pubDate>Sat, 22 Oct 2016 09:45:27 +0000</pubDate>
		<dc:creator><![CDATA[(●'◡'●)]]></dc:creator>
				<category><![CDATA[开发]]></category>
		<category><![CDATA[atom]]></category>
		<category><![CDATA[编辑器]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=106919</guid>
		<description><![CDATA[<p>这篇教程将会教你怎么制作你的第一个 Atom 文本编辑器的插件。我们将会制作一个山寨版的 Sourcerer，这是一个从 StackOverflow 查询并使用代码片段的插件。</p><p><a href="http://blog.jobbole.com/106919/">制作你的第一个 Atom 文本编辑器插件</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<h3>序言</h3>
<p>这篇教程将会教你怎么制作你的第一个 Atom 文本编辑器的插件。我们将会制作一个山寨版的 <a class="ext" href="https://github.com/NickTikhonov/sourcerer" target="_blank" rel="external nofollow">Sourcerer</a>，这是一个从 StackOverflow 查询并使用代码片段的插件。到教程结束时，你将会制作好一个将编程问题（用英语描述的）转换成获取自 StackOverflow 的代码片段的插件，像这样：</p>
<p><img class="alignnone" src="http://ww4.sinaimg.cn/large/63918611gw1f9163k6novg20m80ehnbm.gif" width="800" height="521" /></p>
<h4 id="toc_1">教程须知</h4>
<p>Atom 文本编辑器是用 web 技术创造出来的。我们将完全使用 JavaScript 的 EcmaScript 6 规范来制作插件。你需要熟悉以下内容：</p>
<ul>
<li>使用命令行</li>
<li>JavaScript 编程</li>
<li><a class="ext" href="https://developers.google.com/web/fundamentals/getting-started/primers/promises" target="_blank" rel="external nofollow">Promises</a></li>
<li><a class="ext" href="https://atom.io/" target="_blank" rel="external nofollow">HTTP</a></li>
</ul>
<h4 id="toc_2">教程的仓库</h4>
<p>你可以跟着教程一步一步走，或者看看 <a class="ext" href="https://github.com/NickTikhonov/sourcefetch-guide" target="_blank" rel="external nofollow">放在 GitHub 上的仓库</a>，这里有插件的源代码。这个仓库的历史提交记录包含了这里每一个标题。</p>
<h3 id="toc_3">开始</h3>
<h4 id="toc_4">安装 Atom</h4>
<p>根据 <a class="ext" href="https://atom.io/" target="_blank" rel="external nofollow">Atom 官网</a> 的说明来下载 Atom。我们同时还要安装上 <code>apm</code>（Atom 包管理器的命令行工具）。你可以打开 Atom 并在应用菜单中导航到 <code>Atom &gt; Install Shell Commands</code> 来安装。打开你的命令行终端，运行<code>apm -v</code> 来检查 <code>apm</code> 是否已经正确安装好，安装成功的话打印出来的工具版本和相关环境信息应该是像这样的：</p><pre class="crayon-plain-tag">apm -v
&gt; apm  1.9.2
&gt; npm  2.13.3
&gt; node 0.10.40
&gt; python 2.7.10
&gt; git 2.7.4</pre><p></p>
<h4 id="toc_5">生成骨架代码</h4>
<p>让我们使用 Atom 提供的一个实用工具创建一个新的 <strong>package</strong>（软件包）来开始这篇教程。</p>
<ul>
<li>启动编辑器，按下 <code>Cmd+Shift+P</code>（MacOS）或者 <code>Ctrl+Shift+P</code>（Windows/Linux）来打开命令面板Command Palette。</li>
<li>搜索“Package Generator: Generate Package”并点击列表中正确的条目，你会看到一个输入提示，输入软件包的名称：“sourcefetch”。</li>
<li>按下回车键来生成这个骨架代码包，它会自动在 Atom 中打开。</li>
</ul>
<p>如果你在侧边栏没有看到软件包的文件，依次按下 <code>Cmd+K</code> <code>Cmd+B</code>（MacOS）或者 <code>Ctrl+K</code><code>Ctrl+B</code>（Windows/Linux）。</p>
<p><img class="alignnone" src="http://ww2.sinaimg.cn/large/63918611gw1f9163l36fwg20m80eitf1.gif" width="800" height="522" /></p>
<blockquote><p>Command Palette可以让你通过模糊搜索来找到并运行软件包。这是一个执行命令比较方便的途径，你不用去找导航菜单，也不用刻意去记快捷键。我们将会在整篇教程中使用这个方法。</p></blockquote>
<h4 id="toc_6">运行骨架代码包</h4>
<p>在开始编程前让我们来试用一下这个骨架代码包。我们首先需要重启 Atom，这样它才可以识别我们新增的软件包。再次打开命令面板，执行 <code>Window: Reload</code> 命令。</p>
<p>重新加载当前窗口以确保 Atom 执行的是我们最新的源代码。每当需要测试我们对软件包的改动的时候，就需要运行这条命令。</p>
<p>通过导航到编辑器菜单的 <code>Packages &gt; sourcefetch &gt; Toggle</code> 或者在命令面板执行 <code>sourcefetch:toggle</code> 来运行软件包的 <code>toggle</code> 命令。你应该会看到屏幕的顶部出现了一个小黑窗。再次运行这条命令就可以隐藏它。</p>
<p><img class="alignnone" src="http://ww1.sinaimg.cn/large/63918611gw1f9163nesgdg20m80ey7ka.gif" width="800" height="538" /></p>
<h4 id="toc_7">“toggle”命令</h4>
<p>打开 <code>lib/sourcefetch.js</code>，这个文件包含有软件包的逻辑和 <code>toggle</code> 命令的定义。</p>
<p>&nbsp;</p><pre class="crayon-plain-tag">toggle() {
 console.log('Sourcefetch was toggled!');
 return (
   this.modalPanel.isVisible() ?
   this.modalPanel.hide() :
   this.modalPanel.show()
 );
}</pre><p><code>toggle</code> 是这个模块导出的一个函数。根据模态面板的可见性，它通过一个<a class="ext" href="https://en.wikipedia.org/wiki/%3F:" target="_blank" rel="external nofollow">三目运算符</a> 来调用 <code>show</code> 和<code>hide</code> 方法。<code>modalPanel</code> 是 <a class="ext" href="https://atom.io/docs/api/v1.9.4/Panel" target="_blank" rel="external nofollow">Panel</a>（一个由 Atom API 提供的 UI 元素） 的一个实例。我们需要在 <code>export default</code> 内部声明 <code>modalPanel</code> 才可以让我们通过一个实例变量 <code>this</code> 来访问它。</p><pre class="crayon-plain-tag">this.subscriptions.add(atom.commands.add('atom-workspace', {
  'sourcefetch:toggle': () =&gt; this.toggle()
}));</pre><p>上面的语句让 Atom 在用户运行 <code>sourcefetch:toggle</code> 的时候执行 <code>toggle</code> 方法。我们指定了一个 <a class="ext" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external nofollow">匿名函数</a><code>() =&gt; this.toggle()</code>，每次执行这条命令的时候都会执行这个函数。这是<a class="ext" href="https://en.wikipedia.org/wiki/Event-driven_programming" target="_blank" rel="external nofollow">事件驱动编程</a>（一种常用的 JavaScript 模式）的一个范例。</p>
<h4 id="toc_8">Atom 命令</h4>
<p>命令只是用户触发事件时使用的一些字符串标识符，它定义在软件包的命名空间内。我们已经用过的命令有：</p>
<ul>
<li><code>package-generator:generate-package</code></li>
<li><code>Window:reload</code></li>
<li><code>sourcefetch:toggle</code></li>
</ul>
<p>软件包对应到命令，以执行代码来响应事件。</p>
<h3 id="toc_9">进行你的第一次代码更改</h3>
<p>让我们来进行第一次代码更改——我们将通过改变 <code>toggle</code> 函数来实现逆转用户选中文本的功能。</p>
<h4 id="toc_10">改变 “toggle” 函数</h4>
<p>如下更改 <code>toggle</code> 函数。</p><pre class="crayon-plain-tag">toggle() {
  let editor
  if (editor = atom.workspace.getActiveTextEditor()) {
    let selection = editor.getSelectedText()
    let reversed = selection.split('').reverse().join('')
    editor.insertText(reversed)
  }
}</pre><p></p>
<h4 id="toc_11">测试你的改动</h4>
<ul>
<li>通过在命令面板运行 <code>Window: Reload</code> 来重新加载 Atom。</li>
<li>通过导航到 <code>File &gt; New</code> 来创建一个新文件，随便写点什么并通过光标选中它。</li>
<li>通过命令面板、Atom 菜单或者右击文本然后选中 <code>Toggle sourcefetch</code> 来运行<code>sourcefetch:toggle</code> 命令。</li>
</ul>
<p>更新后的命令将会改变选中文本的顺序：</p>
<p><img class="alignnone" src="http://ww2.sinaimg.cn/large/63918611gw1f9163p3mzcg20m80efn40.gif" width="800" height="519" /></p>
<p>在 <a class="ext" href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/89e174ab6ec6e270938338b34905f75bb74dbede" target="_blank" rel="external nofollow">sourcefetch 教程仓库</a> 查看这一步的全部代码更改。</p>
<h3 id="toc_12">Atom 编辑器 API</h3>
<p>我们添加的代码通过用 <a class="ext" href="https://atom.io/docs/api/v1.11.1/TextEditor" target="_blank" rel="external nofollow">TextEditor API</a> 来访问编辑器内的文本并进行操作。让我们来仔细看看。</p><pre class="crayon-plain-tag">let editor
if (editor = atom.workspace.getActiveTextEditor()) { /* ... */ }</pre><p>头两行代码获取了 <a class="ext" href="https://atom.io/docs/api/latest/TextEditor" target="_blank" rel="external nofollow">TextEditor</a> 实例的一个引用。变量的赋值和后面的代码被包在一个条件结构里，这是为了处理没有可用的编辑器实例的情况，例如，当用户在设置菜单中运行该命令时。</p><pre class="crayon-plain-tag">let selection = editor.getSelectedText()</pre><p>调用 <code>getSelectedText</code> 方法可以让我们访问到用户选中的文本。如果当前没有文本被选中，函数将返回一个空字符串。</p><pre class="crayon-plain-tag">let reversed = selection.split('').reverse().join('')
editor.insertText(reversed)</pre><p>我们选中的文本通过一个 <a class="ext" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="external nofollow">JavaScript 字符串方法</a> 来逆转。最后，我们调用 <code>insertText</code> 方法来将选中的文本替换为逆转后的文本副本。通过阅读 <a class="ext" href="https://atom.io/docs/api/latest/TextEditor" target="_blank" rel="external nofollow">Atom API 文档</a>，你可以学到更多关于 TextEditor 的不同的方法。</p>
<h3 id="toc_13">浏览骨架代码</h3>
<p>现在我们已经完成第一次代码更改了，让我们浏览骨架代码包的代码来深入了解一下 Atom 的软件包是怎样构成的。</p>
<h4 id="toc_14">主文件</h4>
<p>主文件是 Atom 软件包的入口文件。Atom 通过 <code>package.json</code> 里的条目设置来找到主文件的位置：</p><pre class="crayon-plain-tag">"main": "./lib/sourcefetch",</pre><p>这个文件导出一个带有生命周期函数（Atom 在特定的事件发生时调用的处理函数）的对象。</p>
<ul>
<li><strong>activate</strong> 会在 Atom 初次加载软件包的时候调用。这个函数用来初始化一些诸如软件包所需的用户界面元素的对象，以及订阅软件包命令的处理函数。</li>
<li><strong>deactivate</strong> 会在软件包停用的时候调用，例如，当用户关闭或者刷新编辑器的时候。</li>
<li><strong>serialize</strong> Atom 调用它在使用软件包的过程中保存软件包的当前状态。它的返回值会在 Atom 下一次加载软件包的时候作为一个参数传递给 <code>activate</code>。</li>
</ul>
<p>我们将会重命名我们的软件包命令为 <code>fetch</code>，并移除一些我们不再需要的用户界面元素。按照如下更改主文件：</p><pre class="crayon-plain-tag">'use babel';
import { CompositeDisposable } from 'atom'
export default {
  subscriptions: null,
  activate() {
    this.subscriptions = new CompositeDisposable()
    this.subscriptions.add(atom.commands.add('atom-workspace', {
      'sourcefetch:fetch': () =&gt; this.fetch()
    }))
  },
  deactivate() {
    this.subscriptions.dispose()
  },
  fetch() {
    let editor
    if (editor = atom.workspace.getActiveTextEditor()) {
      let selection = editor.getSelectedText()
      selection = selection.split('').reverse().join('')
      editor.insertText(selection)
    }
  }
};</pre><p></p>
<h3 id="toc_15">“启用”命令</h3>
<p>为了提升性能，Atom 软件包可以用时加载。我们可以让 Atom 在用户执行特定的命令的时候才加载我们的软件包。这些命令被称为 <strong>启用命令</strong>，它们在 <code>package.json</code> 中定义：</p><pre class="crayon-plain-tag">"activationCommands": {
  "atom-workspace": "sourcefetch:toggle"
},</pre><p>有一些软件包需要在 Atom 启动的时候被加载，例如那些改变 Atom 外观的软件包。在那样的情况下，<code>activationCommands</code> 会被完全忽略。</p>
<h3 id="toc_16">“触发”命令</h3>
<h4 id="toc_17">菜单项</h4>
<p><code>menus</code> 目录下的 JSON 文件指定了哪些菜单项是为我们的软件包而建的。让我们看看<code>menus/sourcefetch.json</code>：</p><pre class="crayon-plain-tag">"context-menu": {
  "atom-text-editor": [
    {
      "label": "Toggle sourcefetch",
      "command": "sourcefetch:toggle"
    }
  ]
},</pre><p>这个 <code>context-menu</code> 对象可以让我们定义右击菜单的一些新条目。每一个条目都是通过一个显示在菜单的<code>label</code> 属性和一个点击后执行的命令的 <code>command</code> 属性来定义的。</p><pre class="crayon-plain-tag">"context-menu": {
  "atom-text-editor": [
    {
      "label": "Fetch code",
      "command": "sourcefetch:fetch"
    }
  ]
},</pre><p>同一个文件中的这个 <code>menu</code> 对象用来定义插件的自定义应用菜单。我们如下重命名它的条目：</p><pre class="crayon-plain-tag">"menu": [
  {
    "label": "Packages",
    "submenu": [
      {
        "label": "sourcefetch",
        "submenu": [
          {
            "label": "Fetch code",
            "command": "sourcefetch:fetch"
          }
        ]
      }
    ]
  }
]</pre><p></p>
<h4 id="toc_18">键盘快捷键</h4>
<p>命令还可以通过键盘快捷键来触发。快捷键通过 <code>keymaps</code> 目录的 JSON 文件来定义：</p><pre class="crayon-plain-tag">{
  "atom-workspace": {
    "ctrl-alt-o": "sourcefetch:toggle"
  }
}</pre><p>以上代码可以让用户通过 <code>Ctrl+Alt+O</code>（Windows/Linux） 或 <code>Cmd+Alt+O</code>（MacOS） 来触发 <code>toggle</code> 命令。</p>
<p>重命名引用的命令为 <code>fetch</code>：</p><pre class="crayon-plain-tag">"ctrl-alt-o": "sourcefetch:fetch"</pre><p>通过执行 <code>Window: Reload</code> 命令来重启 Atom。你应该会看到 Atom 的右击菜单更新了，并且逆转文本的功能应该还可以像之前一样使用。</p>
<p>在 <a class="ext" href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/aa3ec5585b0aa049393351a30be14590df09c29a" target="_blank" rel="external nofollow">sourcefetch 教程仓库</a> 查看这一步所有的代码更改。</p>
<h3 id="toc_19">使用 NodeJS 模块</h3>
<p>现在我们已经完成了第一次代码更改并且了解了 Atom 软件包的结构，让我们介绍一下 <a class="ext" href="https://www.npmjs.com/" target="_blank" rel="external nofollow">Node 包管理器（npm）</a> 中的第一个依赖项模块。我们将使用 <strong>request</strong> 模块发起 HTTP 请求来下载网站的 HTML 文件。稍后将会用到这个功能来扒 StackOverflow 的页面。</p>
<h4 id="toc_20">安装依赖</h4>
<p>打开你的命令行工具，切换到你的软件包的根目录并运行：</p><pre class="crayon-plain-tag">npm install --save request@2.73.0
apm install</pre><p>这两条命令将 <code>request</code> 模块添加到我们软件包的依赖列表并将模块安装到 <code>node_modules</code> 目录。你应该会在<code>package.json</code> 看到一个新条目。<code>@</code> 符号的作用是让 npm 安装我们这篇教程需要用到的特定版本的模块。运行 <code>apm install</code> 是为了让 Atom 知道使用我们新安装的模块。</p><pre class="crayon-plain-tag">"dependencies": {
  "request": "^2.73.0"
}</pre><p></p>
<h4 id="toc_21">下载 HTML 并将记录打印在开发者控制台</h4>
<p>通过在 <code>lib/sourcefetch.js</code> 的顶部添加一条引用语句引入 <code>request</code> 模块到我们的主文件：</p><pre class="crayon-plain-tag">import { CompositeDisposable } from 'atom'
import request from 'request'</pre><p>现在，在 <code>fetch</code> 函数下面添加一个新函数 <code>download</code> 作为模块的导出项：</p><pre class="crayon-plain-tag">export default {  
  /* subscriptions, activate(), deactivate() */
  fetch() {
    ...
  },
  download(url) {
    request(url, (error, response, body) =&gt; {
      if (!error &amp;&amp; response.statusCode == 200) {
        console.log(body)
      }
    })
  }
}</pre><p>这个函数用 <code>request</code> 模块来下载一个页面的内容并将记录输出到控制台。当 HTTP 请求完成之后，我们的<a class="ext" href="http://recurial.com/programming/understanding-callback-functions-in-javascript/" target="_blank" rel="external nofollow">回调函数</a>会将响应体作为参数来被调用。</p>
<p>最后一步是更新 <code>fetch</code> 函数以调用 <code>download</code> 函数：</p><pre class="crayon-plain-tag">fetch() {
  let editor
  if (editor = atom.workspace.getActiveTextEditor()) {
    let selection = editor.getSelectedText()
    this.download(selection)
  }
},</pre><p><code>fetch</code> 函数现在的功能是将 selection 当作一个 URL 传递给 <code>download</code> 函数，而不再是逆转选中的文本了。让我们来看看这次的更改：</p>
<ul>
<li>通过执行 <code>Window: Reload</code> 命令来重新加载 Atom。</li>
<li>打开开发者工具。为此，导航到菜单中的 <code>View &gt; Developer &gt; Toggle Developer Tools</code>。</li>
<li>新建一个文件，导航到 <code>File &gt; New</code>。</li>
<li>输入一个 URL 并选中它，例如：<code>http://www.atom.io</code>。</li>
<li>用上述的任意一种方法执行我们软件包的命令：</li>
</ul>
<p><img class="alignnone" src="http://ww2.sinaimg.cn/large/63918611gw1f9163s7shhg20m80eh1ba.gif" width="800" height="521" /></p>
<blockquote><p><strong>开发者工具</strong>让 Atom 软件包的调试更轻松。每个 <code>console.log</code> 语句都可以将信息打印到交互控制台，你还可以使用 <code>Elements</code> 选项卡来浏览整个应用的可视化结构——即 HTML 的<a class="ext" href="https://www.wikipedia.com/en/Document_Object_Model" target="_blank" rel="external nofollow">文本对象模型（DOM）</a>。</p></blockquote>
<p>在 <a class="ext" href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/85992043e57c802ca71ff6e8a4f9c477fbfd13db" target="_blank" rel="external nofollow">sourcefetch 教程仓库</a> 查看这一步所有的代码更改。</p>
<h3 id="toc_22">用 Promises 来将下载好的 HTML 插入到编辑器中</h3>
<p>理想情况下，我们希望 <code>download</code> 函数可以将 HTML 作为一个字符串来返回，而不仅仅是将页面的内容打印到控制台。然而，返回文本内容是无法实现的，因为我们要在回调函数里面访问内容而不是在 <code>download</code> 函数那里。</p>
<p>我们会通过返回一个 <a class="ext" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external nofollow">Promise</a> 来解决这个问题，而不再是返回一个值。让我们改动 <code>download</code> 函数来返回一个 Promise：</p><pre class="crayon-plain-tag">download(url) {
  return new Promise((resolve, reject) =&gt; {
    request(url, (error, response, body) =&gt; {
      if (!error &amp;&amp; response.statusCode == 200) {
        resolve(body)
      } else {
        reject({
          reason: 'Unable to download page'
        })
      }
    })
  })
}</pre><p>Promises 允许我们通过将异步逻辑封装在一个提供两个回调方法的函数里来返回获得的值（<code>resolve</code> 用来处理请求成功的返回值，<code>reject</code> 用来向使用者报错）。如果请求返回了错误我们就调用 <code>reject</code>，否则就用<code>resolve</code> 来处理 HTML。</p>
<p>让我们更改 <code>fetch</code> 函数来使用 <code>download</code> 返回的 Promise：</p><pre class="crayon-plain-tag">fetch() {
  let editor
  if (editor = atom.workspace.getActiveTextEditor()) {
    let selection = editor.getSelectedText()
    this.download(selection).then((html) =&gt; {
      editor.insertText(html)
    }).catch((error) =&gt; {
      atom.notifications.addWarning(error.reason)
    })
  }
},</pre><p>在我们新版的 <code>fetch</code> 函数里，我们通过在 <code>download</code> 返回的 Promise 调用 <code>then</code> 方法来对 HTML 进行操作。这会将 HTML 插入到编辑器中。我们同样会通过调用 <code>catch</code> 方法来接收并处理所有的错误。我们通过用<a class="ext" href="https://atom.io/docs/api/v1.11.1/NotificationManager" target="_blank" rel="external nofollow">Atom Notification API</a> 来显示警告的形式来处理错误。</p>
<p>看看发生了什么变化。重新加载 Atom 并在一个选中的 URL 上执行软件包命令：</p>
<p><img class="alignnone" src="http://ww2.sinaimg.cn/large/63918611gw1f9163s7shhg20m80eh1ba.gif" width="800" height="521" /></p>
<p>如果这个 URL 是无效的，一个警告通知将会弹出来：</p>
<p><img class="alignnone" src="http://ww1.sinaimg.cn/large/63918611gw1f9163u3ifug20m80ehtcn.gif" width="800" height="521" /></p>
<p>在 <a class="ext" href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/896d160dca711f4a53ff5b182018b39cf78d2774" target="_blank" rel="external nofollow">sourcefetch 教程仓库</a> 查看这一步所有的代码更改。</p>
<h4 id="toc_23">编写一个爬虫来提取 StackOverflow 页面的代码片段</h4>
<p>下一步涉及用我们前面扒到的 StackOverflow 的页面的 HTML 来提取代码片段。我们尤其关注那些来自采纳答案（提问者选择的一个正确答案）的代码。我们可以在假设这类答案都是相关且正确的前提下大大简化我们这个软件包的实现。</p>
<h4 id="toc_24">使用 jQuery 和 Chrome 开发者工具来构建查询</h4>
<p>这一部分假设你使用的是 <a class="ext" href="https://www.google.com/chrome/" target="_blank" rel="external nofollow">Chrome</a> 浏览器。你接下来可以使用其它浏览器，但是提示可能会不一样。</p>
<p>让我们先看看一张典型的包含采纳答案和代码片段的 StackOverflow 页面。我们将会使用 Chrome 开发者工具来浏览 HTML：</p>
<ul>
<li>打开 Chrome 并跳到任意一个带有采纳答案和代码的 StackOverflow 页面，比如像这个用 Python 写的 <a class="ext" href="http://stackoverflow.com/questions/1077347/hello-world-in-python" target="_blank" rel="external nofollow">hello world</a> 的例子或者这个关于 <a class="ext" href="http://stackoverflow.com/questions/3463426/in-c-how-should-i-read-a-text-file-and-print-all-strings" target="_blank" rel="external nofollow">用 <code>C</code> 来读取文本内容的问题</a>。</li>
<li>滚动窗口到采纳答案的位置并选中一部分代码。</li>
<li>右击选中文本并选择 <code>检查</code>。</li>
<li>使用元素侦察器来检查代码片段在 HTML 中的位置。</li>
</ul>
<p>注意文本结构应该是这样的：</p><pre class="crayon-plain-tag">&lt;div class="accepted-answer"&gt;
  ...
    ...
      &lt;pre&gt;
        &lt;code&gt;
          ...snippet elements...
        &lt;/code&gt;
      &lt;/pre&gt;
    ...
  ...
&lt;/div&gt;</pre><p></p>
<ul>
<li>采纳的答案通过一个 class 为 <code>accepted-answer</code> 的 <code>div</code> 来表示</li>
<li>代码块位于 <code>pre</code> 元素的内部</li>
<li>呈现代码片段的元素就是里面那一对 <code>code</code> 标签</li>
</ul>
<p><img class="alignnone" src="http://ww1.sinaimg.cn/large/63918611gw1f9163wr3zpg20m80egtkr.gif" width="800" height="520" /></p>
<p>现在让我们写一些 <code>jQuery</code> 代码来提取代码片段：</p>
<ul>
<li>在开发者工具那里点击 <strong>Console</strong> 选项卡来访问 Javascript 控制台。</li>
<li>在控制台中输入 <code>$('div.accepted-answer pre code').text()</code> 并按下回车键。</li>
</ul>
<p>你应该会看到控制台中打印出采纳答案的代码片段。我们刚刚运行的代码使用了一个 jQuery 提供的特别的 <code>$</code>函数。<code>$</code> 接收要选择的<strong>查询字符串</strong>并返回网站中的某些 HTML 元素。让我们通过思考几个查询案例看看这段代码的工作原理：</p><pre class="crayon-plain-tag">$('div.accepted-answer')
&gt; [&lt;div id="answer-1077349" class="answer accepted-answer" ... &gt;&lt;/div&gt;]</pre><p>上面的查询会匹配所有 class 为 <code>accepted-answer</code> 的 <code>&lt;div&gt;</code> 元素，在我们的案例中只有一个 div。</p><pre class="crayon-plain-tag">$('div.accepted-answer pre code')
&gt; [&lt;code&gt;...&lt;/code&gt;]</pre><p>在前面的基础上改造了一下，这个查询会匹配所有在之前匹配的 <code>&lt;div&gt;</code> 内部的 <code>&lt;pre&gt;</code> 元素内部的 <code>&lt;code&gt;</code>元素。</p><pre class="crayon-plain-tag">$('div.accepted-answer pre code').text()
&gt; "print("Hello World!")"</pre><p><code>text</code> 函数提取并连接原本将由上一个查询返回的元素列表中的所有文本。这也从代码中去除了用来使语法高亮的元素。</p>
<h3 id="toc_25">介绍 Cheerio</h3>
<p>我们的下一步涉及使用我们创建好的查询结合 <a class="ext" href="https://www.npmjs.com/package/cheerio" target="_blank" rel="external nofollow">Cheerio</a>（一个服务器端实现的 jQuery）来实现扒页面的功能。</p>
<h4 id="toc_26">安装 Cheerio</h4>
<p>打开你的命令行工具，切换到你的软件包的根目录并执行：</p><pre class="crayon-plain-tag">npm install --save cheerio@0.20.0
apm install</pre><p></p>
<h4 id="toc_27">实现扒页面的功能</h4>
<p>在 <code>lib/sourcefetch.js</code> 为 <code>cheerio</code> 添加一条引用语句：</p><pre class="crayon-plain-tag">import { CompositeDisposable } from 'atom'
import request from 'request'
import cheerio from 'cheerio'</pre><p>现在创建一个新函数 <code>scrape</code>，它用来提取 StackOverflow HTML 里面的代码片段：</p><pre class="crayon-plain-tag">fetch() {
  ...
},
scrape(html) {
  $ = cheerio.load(html)
  return $('div.accepted-answer pre code').text()
},
download(url) {
  ...
}</pre><p>最后，让我们更改 <code>fetch</code> 函数以传递下载好的 HTML 给 <code>scrape</code> 而不是将其插入到编辑器：</p><pre class="crayon-plain-tag">fetch() {
  let editor
  let self = this
  if (editor = atom.workspace.getActiveTextEditor()) {
    let selection = editor.getSelectedText()
    this.download(selection).then((html) =&gt; {
      let answer = self.scrape(html)
      if (answer === '') {
        atom.notifications.addWarning('No answer found :(')
      } else {
        editor.insertText(answer)
      }
    }).catch((error) =&gt; {
      console.log(error)
      atom.notifications.addWarning(error.reason)
    })
  }
},</pre><p>我们扒取页面的功能仅仅用两行代码就实现了，因为 cheerio 已经替我们做好了所有的工作！我们通过调用<code>load</code> 方法加载 HTML 字符串来创建一个 <code>$</code> 函数，然后用这个函数来执行 jQuery 语句并返回结果。你可以在官方 <a class="ext" href="https://github.com/cheeriojs/cheerio" target="_blank" rel="external nofollow">开发者文档</a> 查看完整的 <code>Cheerio API</code>。</p>
<h3 id="toc_28">测试更新后的软件包</h3>
<p>重新加载 Atom 并在一个选中的 StackOverflow URL 上运行 <code>soucefetch:fetch</code> 以查看到目前为止的进度。</p>
<p>如果我们在一个有采纳答案的页面上运行这条命令，代码片段将会被插入到编辑器中：</p>
<p><img class="alignnone" src="http://ww4.sinaimg.cn/large/63918611gw1f9163xizcng20m80egn0y.gif" width="800" height="520" /></p>
<p>如果我们在一个没有采纳答案的页面上运行这条命令，将会弹出一个警告通知：</p>
<p><img class="alignnone" src="http://ww1.sinaimg.cn/large/63918611gw1f9163zyj1pg20m80eh0x8.gif" width="800" height="521" /></p>
<p>我们最新的 <code>fetch</code> 函数给我们提供了一个 StackOverflow 页面的代码片段而不再是整个 HTML 内容。要注意我们更新的 <code>fetch</code> 函数会检查有没有答案并显示通知以提醒用户。</p>
<p>在 <a class="ext" href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/039a1e1e976d029f7d6b061b4c0dac3eb4a3b5d2" target="_blank" rel="external nofollow">sourcefetch 教程仓库</a> 查看这一步所有的代码更改。</p>
<h3 id="toc_29">实现用来查找相关的 StackOverflow URL 的谷歌搜索功能</h3>
<p>现在我们已经将 StackOverflow 的 URL 转化为代码片段了，让我们来实现最后一个函数——<code>search</code>，它应该要返回一个相关的 URL 并附加一些像“hello world”或者“快速排序”这样的描述。我们会通过一个非官方的<code>google</code> npm 模块来使用谷歌搜索功能，这样可以让我们以编程的方式来搜索。</p>
<h4 id="toc_30">安装这个 Google npm 模块</h4>
<p>通过在软件包的根目录打开命令行工具并执行命令来安装 <code>google</code> 模块：</p><pre class="crayon-plain-tag">npm install --save google@2.0.0
apm install</pre><p></p>
<h4 id="toc_31">引入并配置模块</h4>
<p>在 <code>lib/sourcefetch.js</code> 的顶部为 <code>google</code> 模块添加一条引用语句：</p><pre class="crayon-plain-tag">import google from "google"</pre><p>我们将配置一下 <code>google</code> 以限制搜索期间返回的结果数。将下面这行代码添加到引用语句下面以限制搜索返回最热门的那个结果。</p><pre class="crayon-plain-tag">google.resultsPerPage = 1</pre><p></p>
<h4 id="toc_32">实现 search 函数</h4>
<p>接下来让我们来实现我们的 <code>search</code> 函数：</p><pre class="crayon-plain-tag">fetch() {
  ...
},
search(query, language) {
  return new Promise((resolve, reject) =&gt; {
    let searchString = `${query} in ${language} site:stackoverflow.com`
    google(searchString, (err, res) =&gt; {
      if (err) {
        reject({
          reason: 'A search error has occured :('
        })
      } else if (res.links.length === 0) {
        reject({
          reason: 'No results found :('
        })
      } else {
        resolve(res.links[0].href)
      }
    })
  })
},
scrape() {
  ...
}</pre><p>以上代码通过谷歌来搜索一个和指定的关键词以及编程语言相关的 StackOverflow 页面，并返回一个最热门的 URL。让我们看看这是怎样来实现的：</p><pre class="crayon-plain-tag">let searchString = `${query} in ${language} site:stackoverflow.com`</pre><p>我们使用用户输入的查询和当前所选的语言来构造搜索字符串。比方说，当用户在写 Python 的时候输入“hello world”，查询语句就会变成 <code>hello world in python site:stackoverflow.com</code>。字符串的最后一部分是谷歌搜索提供的一个过滤器，它让我们可以将搜索结果的来源限制为 StackOverflow。</p><pre class="crayon-plain-tag">google(searchString, (err, res) =&gt; {
  if (err) {
    reject({
      reason: 'A search error has occured :('
    })
  } else if (res.links.length === 0) {
    reject({
      reason: 'No results found :('
    })
  } else {
    resolve(res.links[0].href)
  }
})</pre><p>我们将 <code>google</code> 方法放在一个 <code>Promise</code> 里面，这样我们可以异步地返回我们的 URL。我们会传递由 <code>google</code>返回的所有错误并且会在没有可用的搜索结果的时候返回一个错误。否则我们将通过 <code>resolve</code> 来解析最热门结果的 URL。</p>
<h3 id="toc_33">更新 fetch 来使用 search</h3>
<p>我们的最后一步是更新 <code>fetch</code> 函数来使用 <code>search</code> 函数：</p><pre class="crayon-plain-tag">fetch() {
  let editor
  let self = this
  if (editor = atom.workspace.getActiveTextEditor()) {
    let query = editor.getSelectedText()
    let language = editor.getGrammar().name
    self.search(query, language).then((url) =&gt; {
      atom.notifications.addSuccess('Found google results!')
      return self.download(url)
    }).then((html) =&gt; {
      let answer = self.scrape(html)
      if (answer === '') {
        atom.notifications.addWarning('No answer found :(')
      } else {
        atom.notifications.addSuccess('Found snippet!')
        editor.insertText(answer)
      }
    }).catch((error) =&gt; {
      atom.notifications.addWarning(error.reason)
    })
  }
}</pre><p>让我们看看发生了什么变化：</p>
<ul>
<li>我们选中的文本现在变成了用户输入的 <code>query</code></li>
<li>我们使用 <a class="ext" href="https://atom.io/docs/api/v1.11.1/TextEditor" target="_blank" rel="external nofollow">TextEditor API</a> 来获取当前编辑器选项卡使用的 <code>language</code></li>
<li>我们调用 <code>search</code> 方法来获取一个 URL，然后通过在得到的 Promise 上调用 <code>then</code> 方法来访问这个 URL</li>
</ul>
<p>我们不在 <code>download</code> 返回的 Promise 上调用 <code>then</code> 方法，而是在前面 <code>search</code> 方法本身链式调用的另一个<code>then</code> 方法返回的 Promise 上面接着调用 <code>then</code> 方法。这样可以帮助我们避免<a class="ext" href="http://callbackhell.com/" target="_blank" rel="external nofollow">回调地狱</a></p>
<p>在 <a class="ext" href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/aa9d0b5fc4811a70292869730e0f60ddf0bcf2aa" target="_blank" rel="external nofollow">sourcefetch 教程仓库</a> 查看这一步所有的代码更改。</p>
<h3 id="toc_34">测试最终的插件</h3>
<p>大功告成了！重新加载 Atom，对一个“问题描述”运行软件包的命令来看看我们最终的插件是否工作，不要忘了在编辑器右下角选择一种语言。</p>
<p><img class="alignnone" src="http://ww2.sinaimg.cn/large/63918611gw1f916449g1bg20m80ehnbm.gif" width="800" height="521" /></p>
<h3 id="toc_35">下一步</h3>
<p>现在你知道怎么去 “hack” Atom 的基本原理了，通过 <a class="ext" href="https://github.com/NickTikhonov/sourcefetch-tutorial" target="_blank" rel="external nofollow">分叉 sourcefetch 这个仓库并添加你的特性</a> 来随心所欲地实践你所学到的知识。</p>
<p><a href="http://blog.jobbole.com/106919/">制作你的第一个 Atom 文本编辑器插件</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/106919/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>QA，从 1.0 到 4.0</title>
		<link>http://blog.jobbole.com/106910/</link>
		<comments>http://blog.jobbole.com/106910/#comments</comments>
		<pubDate>Sat, 22 Oct 2016 04:16:48 +0000</pubDate>
		<dc:creator><![CDATA[ThoughtWorks]]></dc:creator>
				<category><![CDATA[IT技术]]></category>
		<category><![CDATA[QA]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=106910</guid>
		<description><![CDATA[<p>敏捷实践不断地演化过程，使项目中各个角色不断弱化，同时，对每个成员的要求也越来越高。“全功能团队”的提出，不单单是对开发的要求，对QA来说，想要在快速变革中具备竞争力，就现在所具备的技能来说，还是远远不够的。

</p><p><a href="http://blog.jobbole.com/106910/">QA，从 1.0 到 4.0</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p>迄今为止，敏捷开发方法在各个公司都有了长足的发展，曾经的测试人员慢慢的在向QA职能过渡，但依然很多人不了解QA和测试的区别是什么。</p>
<p>敏捷实践不断地演化过程，使项目中各个角色不断弱化，同时，对每个成员的要求也越来越高。“全功能团队”的提出，不单单是对开发的要求，对QA来说，想要在快速变革中具备竞争力，就现在所具备的技能来说，还是远远不够的。</p>
<h3>简单聊聊我所经历的“QA发展史”</h3>
<p><a href="http://insights.thoughtworkers.org/wp-content/uploads/2016/10/1-QA4.0.png"><img src="http://insights.thoughtworkers.org/wp-content/uploads/2016/10/1-QA4.0.png" alt="1-qa4-0" width="255" height="1024" /></a></p>
<p>(图片来自ThoughtWorks UX设计师 高媛媛)</p>
<h4>QA 1.0 —— 机械化流水线作业</h4>
<p>在我实习的那年，软件领域还很少提及QA，伴随着瀑布模型的兴起、软件工程规模的不断扩大以及市场对软件质量要求的提高，催生出了“测试工程师”这样一个角色。那时他们的职能很单一，每天的工作就是在各种测试环境中按照详细设计的文档，编写测试用例，并逐条测试，检查功能完整性，发现软件中可能出现的功能缺陷，并进行追踪。</p>
<p>这个时期是软件测试的原始时期，对测试人员的技能要求不高，只要对文档理解透彻，做事细心，是很容易胜任的。此时的产出和交付物可度量，虽然如此，测试工程师只是执行者，能力和价值都无法最大化，却被每天重复的工作所累。</p>
<h4>QA 2.0 —— 过程化带来不同的工作内容和价值体现</h4>
<p>我毕业的时候，开始接触敏捷方法，团队规模从百人变成了仅有十人左右，信息平等取代了逐级传递，分散的信息源（ 客户的每一封邮件和每一句对话都可能是我们将要做的功能 ）取代了几十甚至百页的文档，测试不再仅是提出软件缺陷和编写、执行测试用例，而是成为了团队的数据库和字典。</p>
<p><a href="http://insights.thoughtworkers.org/wp-content/uploads/2016/10/2-dictionary.jpg"><img src="http://insights.thoughtworkers.org/wp-content/uploads/2016/10/2-dictionary-1024x682.jpg" alt="2-dictionary" width="700" height="466" /></a></p>
<p>当用户提出一个功能的时候，测试人员可以快速的进行需求分析，回顾并确定是否与此前的功能有冲突。当开发人员对某一块业务不了解的时候，测试人员也可以组织会议进行阐明。由于对业务和客户的深入了解，测试人员可以为客户提出建设性意见和功能，有时也会是做出决策的人。</p>
<p>高效、频繁的沟通，大大提升了QA的软技能。此时的测试人员已经过程化，对软件质量的理解，从“发现缺陷”提升到“对软件开发过程的质量控制和风险预估”，我们定义这样的测试工程师为QA。</p>
<h4>QA 3.0 —— 自动化技能提高生产力</h4>
<p>随着工程实践的日益成熟，QA的角色和工作日益复杂，这使得他们在大量重复、繁杂的工作与更有意义的角色之间频繁切换，这对软件质量也产生了一定影响。</p>
<p><a href="http://insights.thoughtworkers.org/wp-content/uploads/2016/10/3-transform.jpg"><img src="http://insights.thoughtworkers.org/wp-content/uploads/2016/10/3-transform-1024x682.jpg" alt="3-transform" width="700" height="466" /></a></p>
<p>QA从开始的手工测试、探索性测试等手段，逐渐发展成为可以利用工具和程序对测试进行快速的回归，对软件性能进行有效监控，无论是前端还是后端、web应用还是移动平台。这使得自己从繁杂的重复性工作中解脱出来，去做更有意义的事情。他们通过项目的积累以及团队成员的帮助，对测试技术有了一定的认识。</p>
<h4>QA 4.0 —— 角色向多技能、服务化转型</h4>
<p>记得几年前，前公司领导对我说，“不管开发换了什么技术栈，你做的自动化框架都可以继续使用，对你来说没有任何影响。”当时我也赞同，认为框架已经足够好，可以适用于任何场景和业务。</p>
<p>从某个角度来说确实是这样， 测试相对于开发技术的指数级发展，平稳的太多。不论是在互联网还是移动互联网时代，缓慢的发展速度给了我们一种太平盛世的错觉，似乎我们掌握的技术足够坐吃几年。</p>
<p>来到ThoughtWorks之后，我发现了类似的事情，不论是在交付还是咨询的过程中，会有意无意中推一些我们认为的最佳实践，当遭到客户质疑和challenge的时候，我们似乎很沮丧。</p>
<p>在北京出差的日子，有幸做了一次咨询，虽然只有几天，让我学到一件事，我们认为的最佳实践和方法，并不完全适应于所有场合，尤其是在我们这样的咨询公司，对客户实施怎样的方案，取决于客户的领域、产品/项目特性、用户群、技术水平、政治文化、技术栈以及目标和期望等等。</p>
<p><a href="http://insights.thoughtworkers.org/wp-content/uploads/2016/10/4-balance.jpg"><img src="http://insights.thoughtworkers.org/wp-content/uploads/2016/10/4-balance.jpg" alt="4-balance" width="1000" height="707" /></a></p>
<p><strong>如果对于“最佳实践”过于坚持，也会影响客户关系和咨询效果。</strong>之后咨询同事讲的几个故事也似乎让我认识到，虽然我们对现在的工作和技能足够的熟练，但依然不够。</p>
<h3>我们似乎还需要具备以下的能力：</h3>
<p>1.尝试用不同的方法写“茴”</p>
<p>经验丰富的QA对于测试技术中的关键点都烂熟于心， 除了我们正在使用的方案和技术，尝试用不同的语言、框架去实现关键点和难点。这样的好处在于，我们可以通过深入的学习和使用，对流行方法、过程和框架进行比较，了解各自的优势和劣势，不但可以增强自身的技能，当面对不同客户的时候，也可以给出客观的分析，为客户提供精准服务，同时如果可以对客户现有的技术和方案、流程和方法提供有价值的意见，也可以提高在客户现场的生存率，轻松俘获客户。</p>
<p>2.If you cannot test it, dev it.</p>
<p>软件过程中，QA可以在<strong>需求分析和定义阶段</strong>介入，为项目提供不可估量的价值，但另一方面，QA技能实践（此处指Tech）是一个相对受限的领域，我们很难绕过未实现的代码和工程去做更多的事情。</p>
<p>你可能会说，“没有做过mobile的项目，如何去学习移动端的测试技能？”如果恰好你对行业的发展具有前瞻性和敏感度，例如你可能认为IoT和VR是一个趋势，你却没有机会去这样的项目中做QA。</p>
<p>那么我们是不是可以像开发一样，提升自己的学习能力和适应力，保持对技术的敏感度和热忱，了解不同技术领域，对该领域的开发、测试、构建和集成部署都有一定的了解？所以，如果你想比其他人走的快那么一点，go dev!</p>
<p><a href="http://insights.thoughtworkers.org/wp-content/uploads/2016/10/5-golf.jpg"><img src="http://insights.thoughtworkers.org/wp-content/uploads/2016/10/5-golf-1024x637.jpg" alt="5-golf" width="700" height="435" /></a></p>
<p>3.真正的全功能</p>
<p>QA的领域虽然相对受限，但幸运的是角色相对不受限。在日常的开发过程和项目积累过程中，不但能对业务有深刻的理解、对用户行为有独到的见解，而且对技术也有一定的认识。</p>
<p>在需求分析过程中，QA总是可以从技术和业务结合的角度扮演好一个BA的角色，成为一个优秀的PM，甚至我们可以在客户提出一些需求的时候尝试着从一个UX的角度去设计原型，如果具备前端的能力，也可以自己去Dev、UI，不断拓展自己的技能领域，使自己成为真正的全功能。</p>
<h3>总结</h3>
<p>真正的全功能，并不是单纯意义上让QA去做Dev，而是最大程度弱化角色的概念，逐步强调和培养技能多元化。如何把对需求的理解能力强化为业务分析能力，把质量控制能力强化为项目管理能力。<strong>强化自身的优势，跳出自己的舒适区，使自己能够轻松胜任。这样我们才不会在看到去QA和QA消亡之类的观点后，无所适从。</strong></p>
<p><a href="http://blog.jobbole.com/106910/">QA，从 1.0 到 4.0</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/106910/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>C++ 虚函数和虚继承浅析</title>
		<link>http://blog.jobbole.com/106912/</link>
		<comments>http://blog.jobbole.com/106912/#respond</comments>
		<pubDate>Sat, 22 Oct 2016 01:15:36 +0000</pubDate>
		<dc:creator><![CDATA[中二饼]]></dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[C语言]]></category>
		<category><![CDATA[虚函数]]></category>
		<category><![CDATA[虚继承]]></category>

		<guid isPermaLink="false">http://blog.jobbole.com/?p=106912</guid>
		<description><![CDATA[<p>本文针对C++里的虚函数，虚继承表现和原理进行一些简单分析，有不对的地方请指出。下面都是以VC2008编译器对这两种机制内部实现为例。</p><p><a href="http://blog.jobbole.com/106912/">C++ 虚函数和虚继承浅析</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></description>
				<content:encoded><![CDATA[<p>本文针对C++里的虚函数，虚继承表现和原理进行一些简单分析，有不对的地方请指出。下面都是以VC2008编译器对这两种机制内部实现为例。</p>
<div id="cnblogs_post_body">
<h3>虚函数</h3>
<p><strong>　　</strong>一下是百度百科对于虚函数的解释：</p>
<blockquote>
<div>定义：在某基类中声明为 virtual 并在一个或多个派生类中被重新定 义的成员函数<sup>[1]</sup></div>
<div>语法：virtual 函数返回类型 函数名（参数表） { 函数体 }</div>
<div>用途<strong>：</strong>实现多态性，通过指向派生类的基类指针，访问派生类中同名覆盖成员函数</div>
</blockquote>
<p>函数声明和定义和普通的类成员函数一样，只是在返回值之前加入了关键字“virtual”声明为虚函数。而虚函数是实现多态的重要手段，意思是只有对虚函数的调用才能动态决定调用哪一个函数，这是相对于普通成员函数而言的，普通的成员函数在编译阶段就能确定调用哪一个函数。举个栗子：</p>
<div>
<pre class="crayon-plain-tag">#include &lt;stdio.h&gt;

class A {
public:
    void fn() { printf("fn in A\n"); }
    virtual void v_fn() { printf("virtual fn in A\n"); }
};

class B : public A {
public:
    void fn() { printf("fn in B\n"); }
    virtual void v_fn() { printf("virtual fn in B\n"); }
};

int main() {
    A *a = new B();
    a-&gt;fn();
    a-&gt;v_fn();
    return 0;
}</pre>
</div>
<p>基类A有两个成员函数fn和v_fn，派生类B继承自基类A，同样实现了两个函数，然后在main函数中用A的指针指向B的实例（向上转型，也是实现多态的必要手段），然后分别调用fn和v_fn函数。结果是“fn in A&#8221;和&#8221;virtual fn in B&#8221;。</p>
<p>这是因为fn是普通成员函数，它是通过类A的指针调用的，所以在编译的时候就确定了调用A的fn函数。而v_fn是虚函数，编译时不能确定，而是在运行时再通过一些机制来调用指针所指向的实例（B的实例）中的v_fn函数。假如派生类B中没有实现（完全一样，不是重载）v_fn这个函数，那么依然会调用基类类A中的v_fn；如果它实现了，就可以说派生类B覆盖了基类A中的v_fn这个虚函数。这就是虚函数的表现和使用，只有通过虚函数，才能实现面向对象语言中的多态性。</p>
<p>以上只是虚函数的表现和用途，下面来探讨它的实现机制。在此之前，先来看一个问题，还是以上的代码，基类A的大小为多少，也就是“printf(&#8220;%dn&#8221;, sizeof(A));&#8221;的输出会是多少呢？A中一个成员变量都没有，有人可能会说是0。额，0是绝对错误的，因为在C++中，即时是空类，它的大小也为1，这是另外的话题，不在本文讨论。当然1也是不对的，实际结果是4（32位系统），4刚好是一个int，一个指针（32位）的大小，派生类B的大小同样为4。这四个字节和实现多态，虚函数的机制有着很重要的关系。</p>
<p>其实用VC2008调试上面代码的时候，就会发现指针a所指向的实力中有一个成员常量（const），它的名字叫做vftable，全称大概叫做virtual function table（虚函数表）。它实际指向了一个数组，数组里面保存的是一系列函数指针，而上面的程序中，这个表只有一项，它就是派生类B中的v_fn函数入口地址。假如我们用一个A的指针指向一个A的实例呢？它同样有一个vftable，而它指向的表中也只有一项，这项保存的基类的v_fn函数入口地址。这用代码表示，就类似于下面这样：</p>
<div>
<pre class="crayon-plain-tag">void* vftable_of_A[] = {
    A::v_fn,
    ...
};

class A {
    const void* vftable = vftable_of_A;
    virtual void v_fn() {}
};

void* vftable_of_B[] = {
    B::v_fn,
    ...
};

class B {
    const void *vftable = vftable_of_B;
    vritual void v_fn() {}
};</pre>
</div>
<p>上面vftable的类型之所以用void*表示，实际上一个类中所有虚函数的地址都被放到这个表中，不同虚函数对应的函数指针类型不尽相同，所以这个表用C++的类型不好表述，但是在机器级里都是入口地址，即一个32位的数字（32位系统），等到调用时，因为编译器预先知道了函数的参数类型，返回值等，可以自动做好处理。</p>
<p>这样我们就能更好的理解虚函数和多态了。第一个代码中，a指针虽然是A*类型的，但是它却调用了B中的v_fn，因为不管是A类，还是A的基类，都会有一个变量vftable，它指向的虚函数表中保存了正确的v_fn入口。所以a-&gt;v_fn()实际做的工作就是从a指向的实例中取出vftable的值，然后找到虚函数表，再从表中去的v_fn的入口，进行调用。不管a是指向A的实例，还是指向B的实例，a-&gt;fn()所做的步骤都是上面说的一样，只是A的实例和B的实例有着不同的虚函数表，虚函数表里也保存着可能不同的虚函数入口，所以最终将进入不同的函数调用中。通过表来达到不用判断类型，亦可实现多态的作用。还有一点指的提醒的是，因为虚函数表是一个常量表，在编译时，编译器会自动生成，并且不会改变，所以如果有多个B类的实例，每个实例中都会有一个vftable指针，但是它们指向的是同一个虚函数表。</p>
<p>上面一段中说到了，A和B的实例有着不同的虚函数表，但是虚函数表中只是可能保存着不同的v_fn，那是因为C++允许派生类不覆盖基类中的虚函数，意思就是假如派生类B中没有实现v_fn这个函数（不是重载），那么B的实例的虚函数表会保存着基类A中v_fn的入口地址。也就是说B类不实现v_fn函数，但是它同样提供了这个接口，实际上是调用基类A中的v_fn。假如某个类只是一个抽象类，抽象出一些列接口，但是又不能实现这些接口，而要有派生类来实现，那么就可以把这些接口声明为<strong>纯虚函数</strong>，包含有纯虚函数的类称为<strong>抽象类</strong>。纯虚函数是一类特殊的虚函数，它的声明方式如下：</p>
<blockquote><p>class A {</p>
<p>public:</p>
<p>virtual 返回值 函数名（参数表）= 0；</p>
<p>};</p></blockquote>
<p>在虚函数声明方式后加一个“=0”，并且不提供实现。抽象类不允许实例化（这样做编译器会报错，因为有成员函数没有实现，编译器不知道怎么调用）。纯虚函数的实现机制和虚函数类似，只是要求派生类类必须自己实现一个（也可以不实现，但是派生类也会是个抽象类，不能实例化）。</p>
<p>顺带提一下，java中的每一个成员函数都可以以理解为C++中的virtual函数，不用显式声明都可以实现重载，多态。而java的接口类似于C++中的抽象类，需要实现里面的接口。</p>
<h3>虚继承</h3>
<p>C++支持多重继承，这和现实生活很类似，任何一个物体都不可能单一的属于某一个类型。就像马，第一想到的就是它派生自动物这个基类，但是它在某系地方可不可以说也派生自交通工具这一个基类呢？所以C++的多重继承很有用，但是又引入了一个问题（专业术语叫做菱形继承？）。动物和交通工具都是从最根本的基类——“<strong>事物”</strong>继承而来，事物包含了两个最基本的属性，体积和质量。那么动物和交通工具都保存了基类成员变量——体积和质量的副本。而马有继承了这两个类，那么马就有两份体积和质量，这是不合理的，编译器无法确定使用哪一个，所以就会报错。JAVA中不存在这样的问题，因为JAVA不允许多重继承，它只可能实现多个接口，而接口里面只包含一些函数声明不包含成员变量，所以也不存在这样的问题。</p>
<p>这个问题用具体代码表述如下所示：</p>
<div>
<pre class="crayon-plain-tag">class A {
public:
    int a;
};

class B : public A {
};

class C : public A {
};

class D : public B, public C {
};

int main() {
    D d;
    d.a = 1;
    return 0;
}</pre>
</div>
<p>这个代码会报错，因为d中保存了两份A的副本，即有两个成员变量a，一般不会报错，但是一旦对D中的a使用，就会报一个“对a的访问不明确”。虚继承就可以解决这个问题。在探讨虚函数之前，先来一个sizeof的问题。</p>
<div>
<pre class="crayon-plain-tag">#include &lt;stdio.h&gt;

class A {
public:
    int a;
};

class B : virtual public A {
};


int main() {
    printf("%d\n", sizeof(B));
    return 0;
}</pre>
</div>
<p>B的大小是？首先回答0的是绝对错的，理由我之前都说了。1也是错的，不解释。4也是错的，如果B不是虚继承自A的，那么4就是对的。正确答案是8，B虚继承A了之后，比预想中的多了4个字节，这是怎么回事呢？这个通过调试是看不出来的，因为看不到类似于vftable的成员变量（实际上编译器生成了一个类似的东西，但是调试时看不到，但是在观察反汇编的时候，可以见到vbtable的字样，应该是virtual base table的意思）。</p>
<p>虚继承的提出就是为了解决多重继承时，可能会保存两份副本的问题，也就是说用了虚继承就只保留了一份副本，但是这个副本是被多重继承的基类所共享的，该怎么实现这个机制呢？编译器会在派生类B的实例中保存一个A的实例，然后在B中加入一个变量，这个变量是A的实例在实际B实例中的偏移量，实际上B中并不直接保存offset的值，而是保存的一个指针，这个指针指向一个表vbtable，vbtable表中保存着所有虚继承的基类在实例中的offset值，多个B的实例共享这个表，每个实例有个单独的指针指向这个表，这样就很好理解为什么多了4个字节了。用代码表示就像下面这样。</p>
<div>
<pre class="crayon-plain-tag">class A {
public:
    ...
};

int vbtable_of_B[] = {
　　offset(B::_a),
    ...
};


class B ：virtual public A{
private:
    const int* vbtable = vbtable_of_B;
    A _a;
};</pre>
</div>
<p>每一个A的虚派生类，都会有自己的vbtable表，这个派生类的所有实例共享这个表，然后每个实例各自保存了一个指向vbtable表的指针。假如还有一个类C虚继承了A，那么编译器就会为它自动生成一个vbtable_of_C的表，然后C的实例都会有一个指向这个vbtable表的指针。</p>
<p>假如有多级的虚继承会发生什么情况，就像下面这段代码一样：</p>
<div>
<pre class="crayon-plain-tag">#include &lt;stdio.h&gt;

class A {
public:
    int a;
};

class B : virtual public A {
public:
　　int b;
};

class C : virtual public B {
};


int main() {
    printf("%d\n", sizeof(C));
    return 0; 
}</pre>
</div>
<p>程序运行的结果是16，按照之前的理论，大概会这么想。基类A里有1个变量，4个字节。B类虚继承了A，所以它有一个A的副本和一个vbtable，还有自己的一个变量，那就是12字节。然后C类又虚继承了B类，那么它有一个B的副本，一个vbtable，16字节。但实际上通过调试和反汇编发现，C中保存分别保存了A和B的副本（不包括B类的vbtable），8字节。然后有一个vbtable指针，4字节，表里面包含了A副本和B副本的偏移量。最后还有一个无用的4字节（？），一共16字节。不仅是这样，每经过一层的虚继承，便会多出4字节。这个多出来的四字节在反汇编中没发现实际用途，所以这个有待探讨，不管是编译器不够智能，还是有待其它作用，虚继承和多重继承都应该谨慎使用。</p>
<p>还是以上面的例子，假如C类是直接继承B类，而不是使用虚继承，那么C类的大小为12字节。它里面是直接保存了A和B的副本（不包含B的vbtable），然后还有一个自己的vbtable指针，所以一共12字节，没有了上一段所说的最后的4个字节。</p>
<p>但是如果想下面一种继承，会是什么情况？</p>
<div>
<pre class="crayon-plain-tag">#include &lt;stdio.h&gt;

class A {
public:
    int a;
};

class B : virtual public A {
};

class C : virtual public A {
};

class D : public B, public C{
};


int main() {
    printf("%d\n", sizeof(D));
    return 0; 
}</pre>
</div>
<p>D从B，C类派生出来，而B和C又同时虚继承了A。输出的结构是12，实际调试反汇编的时候发现，D中继承了B和C的vbtable，这就是8字节，而同时还保存了一个A的副本，4字节，总共12字节。它和上面的多重虚继承例子里的12字节是不一样的。之前一个例子中只有一个vbtable，一个A的实例，末尾还有一个未知的4字节。而这个例子中是有两个仅挨着的vbtable（都有效）和一个A的实例。</p>
</div>
<p><a href="http://blog.jobbole.com/106912/">C++ 虚函数和虚继承浅析</a>，首发于<a href="http://blog.jobbole.com">文章 - 伯乐在线</a>。</p>]]></content:encoded>
			<wfw:commentRss>http://blog.jobbole.com/106912/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
